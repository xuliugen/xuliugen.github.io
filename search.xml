<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[带你发现新大陆！什么是图数据库以及简单入门！]]></title>
      <url>/article/Neo4j/What-is-graph-database-and-how-to-get-start.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><h2 id="一、关系型数据库的不适性"><a href="#一、关系型数据库的不适性" class="headerlink" title="一、关系型数据库的不适性"></a>一、关系型数据库的不适性</h2><p>在众多不同的数据模型里，关系数据模型自20世纪80年代就处于统治地位，而且出现了不少巨头，如Oracle、MySQL，它们也被称为：<strong>关系数据库管理系统</strong>（RDBMS）。然而，随着关系数据库使用范围的不断扩大，也暴露出一些它始终无法解决问题，其中最主要的是数据建模中的一些缺陷和问题，以及在大数据量和多服务器之上进行水平伸缩的限制。同时，互联网发展也产生了一些新的趋势变化：</p><ol><li><p>用户、系统和传感器产生的数据量呈指数增长，数据量不断增加，大数据的存储和处理；</p></li><li><p>新时代互联网形势下的问题急迫性，这一问题因互联网+、社交网络，智能推荐等的大规模兴起和繁荣而变得越加紧迫。</p></li></ol><p>而在应对这些趋势时，关系数据库产生了更多的不适应性，从而导致大量解决这些问题中某些特定方面的不同技术出现，它们可以与现有RDBMS相互配合或代替它们。过去的几年间，出现了大量新型数据库，它们被统称为NoSQL数据库。</p><h2 id="二、NoSQL数据库的数据模型"><a href="#二、NoSQL数据库的数据模型" class="headerlink" title="二、NoSQL数据库的数据模型"></a>二、NoSQL数据库的数据模型</h2><p>NoSQL（Not Only SQL，不限于SQL）是一类范围非常广泛的持久化解决方案，它们不遵循关系数据库模型，也不使用SQL作为查询语言。其数据存储可以不需要固定的表格模式，也经常会避免使用SQL的JOIN操作，一般有水平可扩展的特征。</p><p>简言之，NoSQL数据库可以按照它们的数据模型分成4类：</p><ol><li>键-值存储库（Key-Value-stores）;</li><li>BigTable实现（BigTable-implementations）;</li><li>文档库（Document-stores）;</li><li>图形数据库（Graph Database）;</li></ol><p>在NoSQL四种分类中，图数据库从最近十年的表现来看已经成为关注度最高，也是发展趋势最明显的数据库类型。下图就是db-engines.com对最近三年来所有数据库种类发展趋势的分析结果：</p><p><img src="http://img.blog.csdn.net/20180117153650051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>看到这里如果以前没有对图数据库有所了解的话可能还是一头雾水，图数据库到底是什么东西！下边我们首先通过一个小案例说一下使用图数据的紧迫性！</p><h2 id="三、新时期互联网下什么最重要？"><a href="#三、新时期互联网下什么最重要？" class="headerlink" title="三、新时期互联网下什么最重要？"></a>三、新时期互联网下什么最重要？</h2><p>新时期的互联网下，对于一个公司什么最重要？当然是流量！一个初创公司只要有流量，就可以轻轻松松拿到投资，一个大型互联网只要有流量，就可以轻轻松松躺着赚钱！为了流量企业也是和移动运营商”相互勾结”，推出了诸如：大王卡、大牛卡、宝卡、日租卡、平台应用免流卡等等，各种各样的手机SIM卡，唯一的目的不过就是圈人头！</p><p>为了圈人头各大公司也是绞尽脑汁，按照增长黑客的指导思想，病毒式的营销方案！利用各种高深算法像你推荐各种东西，例如：脉脉，职场中会向你推荐同一所高校毕业的同事，同一个家乡的同事等等，这些都属于二度人脉的推广！</p><p>如果把你的微信好友作为一度人脉的话，那么你微信好友的好友就属于你的二度人脉，而你微信好友的好友的好友就是你的三度人脉，画个图简单看一下（图A）：</p><p><img src="http://img.blog.csdn.net/20180117164441447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>通常情况下我们所指的二度人脉基本都是一个泛指，泛指除了一度人脉之外的所有关联的人脉关系，如：三度、四度、五度甚至六度人脉等！</p><p>那么问题来了，如果让你实现推荐二度人脉这个功能，你会如何实现哪？</p><h2 id="四、二度人脉推荐实现及对比"><a href="#四、二度人脉推荐实现及对比" class="headerlink" title="四、二度人脉推荐实现及对比"></a>四、二度人脉推荐实现及对比</h2><p>相信有一定基础的小伙伴都可以很轻松的实现一个推荐二度人脉的数据库表设计和代码实现。数据库首先有一个用户表<code>user</code>，用于表示用户的基本信息，然后一个有一个好友表<code>user_friends</code>，用于表示好友之间的关系。查找你的一度人脉就是直接根据你的用户ID到<code>user_friends</code>表中查找好友的ID；查找你的二度人脉是先根据你的用户ID去<code>user_friends</code>表中先查出来你的一度人脉，然后得到所有一度人脉的用户ID，然后根据这些所有一度人脉的用户ID再去<code>user_friends</code>中查找他的好友！那么如果让你查找三度、四度、五度人脉哪？哇！想都不敢想！一个复杂的人脉关系网例如图B：</p><p><img src="http://img.blog.csdn.net/20180117172025957?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>如果你确实厉害，对于上述查找三度、四度、五度人脉都是小意思！那么帮忙查一个五度范围内和我是同一个家乡的好友！注意：这里加了一个附加属性“同一个家乡”！可能此时你还认为这是一件简单的事，也不过是先把所有的五度范围内的人脉找出来，然后在搜索一下和我是同一个家乡的而已！</p><p>厉害了！可能此时你的代码已经完成，然后准备测试！但是，此时的结果可能会让你失望！查询的效率可能会极低极低！完全是一个无法接受的范围！（后边会有测试看结果！）</p><p>有想法的小伙伴可能已经注意了，利用自己所学的知识，图B不就是一张我们数据结构中的有向图吗？而搜索二度人脉、三度人脉等不就相当于图的一个节点到达另一个节点的路径为2、为3的搜索吗？而图的搜索常用的算法不就是深度优先算法、广度优先算法、迪克拉斯算法吗？</p><p>看到这里，感觉到你已经领略到图数据库的精髓了！图数据库可以很轻松的实现上述二度人脉、三度人脉等的查询。</p><p>有一个很有意思的测试，一种是通过关系型数据实现上述功能，一种是通过图数据库实现上述功能，测试的案例是：我们希望在一个社交网络里找到最大深度为5的朋友的朋友。假设随机选择两个人，是否存在一条路径，使得关联他们的关系长度最多为5？对于一个包含100万人，每人约有50个朋友的社交网络， 图数据库与关系型数据库执行时间对比：</p><p><img src="http://img.blog.csdn.net/20180117171306618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>在深度为2时（即朋友的朋友），假设在一个在线系统中使用，无论关系型数据库还是图数据库，在执行时间方面都表现得足够好。虽然Neo4j的查询时间为关系数据库的2/3，但终端用户很难注意到两者间毫秒级的时间差异。当深度为3时（即朋友的朋友的朋友），很明显关系型数据库无法在合理的时间内实现查询：一个在线系统无法接受30s的查询时间。相比之下，Neo4j的响应时间则保持相对平坦：执行查询仅需要不到1s，这对在线系统来说足够快了。</p><p>在深度为4时，关系型数据库表现出很严重的延迟，使其无法应用于在线系统。Neo4j所花时间也有所增加，但其时延在在线系统的可接受范围内。最后，在深度为5时，关系型数据库所花时间过长以至于没有完成查询。相比之下，Neo4j则在2 s左右的时间就返回了结果。在深度为5时，事实证明几乎整个网络都是我们的朋友，因此在很多实际用例中，我们可能需要修剪结果，并进行时间控制。</p><p>将社交网络替换为任何其他领域时，你会发现图数据库在性能、建模和维护方面都能获得类似的好处。无论是音乐还是数据中心管理，无论是生物信息还是足球统计，无论是网络传感器还是时序交易，图都能对这些数据提供强有力而深入的理解。</p><p>而关系型数据库对于超出合理规模的集合操作普遍表现得不太好。当我们试图从图中挖掘路径信息时，操作慢了下来。我们并非想要贬低关系型数据库，它在所擅长的方面有很好的技术能力，但在管理关联数据时却无能为力。任何超出寻找直接朋友或是寻找朋友的朋友这样的浅遍历查询，都将因为涉及的索引数量而使查找变得缓慢。而图数据库由于使用的是图遍历技术，所需要计算的数据量远小于关系型数据库，所以非常迅速。</p><p>此时，我们还没有真正的了解到底什么是图数据库，但是我们已经可以领略到图数据库的威力了！</p><h2 id="五、揭开图数据库的面纱"><a href="#五、揭开图数据库的面纱" class="headerlink" title="五、揭开图数据库的面纱"></a>五、揭开图数据库的面纱</h2><p>图数据库源起欧拉和图理论，也可称为面向/基于图的数据库，对应的英文是Graph Database。图数据库的基本含义是以“图”这种数据结构存储和查询数据，而不是存储图片的数据库。它的数据模型主要是以<strong>节点和关系</strong>（边）来体现，也可处理键值对。它的优点是快速解决复杂的关系问题。</p><p>图具有如下特征：</p><ol><li>包含节点和边；</li><li>节点上有属性（键值对）；</li><li>边有名字和方向，并总是有一个开始节点和一个结束节点；</li><li>边也可以有属性。</li></ol><p><img src="http://img.blog.csdn.net/20180117210938255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>说得正式一些，图可以说是顶点和边的集合，或者说更简单一点儿，图就是一些节点和关联这些节点的联系（relationship）的集合。</p><p>通常，在图计算中，基本的数据结构表达就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">G=(V, E) </span><br><span class="line">V=vertex（节点） </span><br><span class="line">E=edge（边）</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="http://img.blog.csdn.net/20180117191007057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>图数据库名字的由来其实与其在底层的存储方式有关，Neo4j底层会以图的方式把用户定义的节点以及关系存储起来，通过这种方式，可以高效的实现从某个节点开始，通过节点与节点间关系，找出两个节点间的联系。</p><p>从这段描述中可以猜得到，在Neo4j中最重要的两个元素就是节点和关系。说到节点和关系，就必须引出一个非常重要的概念，属性图模型(Property Graph Model)。如下所示:</p><p><img src="http://img.blog.csdn.net/20180117190648930?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ol><li>一个图中会记录节点和关系；</li><li>关系可以用来关联两个节点 ；</li><li>节点和关系都可以拥有自己的属性；</li><li>可以赋予节点多个标签(类别)；</li></ol><h2 id="六、图数据库的代表Neo4j"><a href="#六、图数据库的代表Neo4j" class="headerlink" title="六、图数据库的代表Neo4j"></a>六、图数据库的代表Neo4j</h2><p>目前市面上有很多图数据库，例如：Neo4J、ArangoDB、OrientDB、FlockDB、GraphDB、InfiniteGraph、Titan、Cayley等，但目前较为活跃可以称之为代表的当属Neo4j。</p><p>Neo4j官方地址：<a href="https://neo4j.com/" target="_blank" rel="noopener">https://neo4j.com/</a></p><p>Neo4j的安装使用很简单，如果是Window平台的话直接安装就可以，然后配置一下环境变量即可使用！这里不再介绍，下边看一下简单使用。</p><p><strong>1，Neo4j浏览器：</strong></p><p>Neo4j服务器具有一个集成的浏览器，在一个运行的服务器实例上访问 “<a href="http://localhost:7474/”，打开浏览器，显示启动页面：" target="_blank" rel="noopener">http://localhost:7474/”，打开浏览器，显示启动页面：</a></p><p><img src="http://img.blog.csdn.net/20180117204335019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>默认的host是<code>bolt://localhost:7687</code>，默认的用户是neo4j，其默认的密码是：neo4j，第一次成功登陆到Neo4j服务器之后，需要重置密码。访问Graph Database需要输入身份验证，Host是Bolt协议标识的主机。</p><p><strong>2，在Neo4j浏览器中创建节点和关系：</strong></p><p>示例，编写Cypher命令，创建两个节点和两个关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE (n:Person &#123; name: &apos;Andres&apos;, title: &apos;Developer&apos; &#125;) return n;</span><br><span class="line">CREATE (n:Person &#123; name: &apos;Vic&apos;, title: &apos;Developer&apos; &#125;) return n;</span><br><span class="line">match(n:Person&#123;name:&quot;Vic&quot;&#125;),(m:Person&#123;name:&quot;Andres&quot;&#125;) create (n)-[r:Friend]-&gt;(m) return r;</span><br><span class="line">match(n:Person&#123;name:&quot;Vic&quot;&#125;),(m:Person&#123;name:&quot;Andres&quot;&#125;) create (n)&lt;-[r:Friend]-(m) return r;</span><br></pre></td></tr></table></figure><p>在$ 命令行中，编写Cypher脚本代码，点击Play按钮，点击创建第一个节点：</p><p><img src="http://img.blog.csdn.net/20180117204359075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>3、在第一个节点创建之后，在Graph模式下，能够看到创建的图形，继续编写Cypher脚本，创建其他节点和关系：</p><p><img src="http://img.blog.csdn.net/20180117204458214?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>4、在创建完两个节点和关系之后，查看数据库中的图形：</p><p><img src="http://img.blog.csdn.net/20180117204519560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>图数据库它善于处理大量的、复杂的、互联的、多变的网状数据，其效率远远高于传统的关系型数据库的百倍、千倍甚至万倍。图数据库特别适用于社交网络、实时推荐、银行交易环路、金融征信系统等广泛的领域。领英、沃尔玛、CISCO、HP、eBay等全球知名企业都在使用图数据库Neo4j，中国企业也在逐步开始用图数据库来构建自己的应用。</p><p>上文从查找二度人脉的角度一步步引出了图形数据库，并简单的介绍了其概念。本文的主要目的还是以介绍为主，带你认识新技术，而更多的使用以及各种图形数据库之间的对比，优点缺点，仅仅靠一篇文章是完全不够的！还望读者下来之后观望阅读或者自行查找资料进行学习！</p><p>如果你还没有接触过或者用到图数据库，相信我不久的将来你肯定会接触到或者用到！趁着图形数据库现在还不像MySql或者Redis那样普遍，抓住机会！赶紧好好学习一下吧！</p><hr><p>参考文章：</p><p>1、<a href="http://www.iteye.com/news/32186" target="_blank" rel="noopener">http://www.iteye.com/news/32186</a></p><p>2、<a href="https://www.jianshu.com/p/97c6752e928b" target="_blank" rel="noopener">https://www.jianshu.com/p/97c6752e928b</a></p><p>3、<a href="https://www.cnblogs.com/ljhdo/archive/2017/05/19/5521577.html" target="_blank" rel="noopener">https://www.cnblogs.com/ljhdo/archive/2017/05/19/5521577.html</a></p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> 数据库 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Neo4j </tag>
            
            <tag> 图数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式锁简单入门以及三种实现方式介绍]]></title>
      <url>/article/Distributed/Distributed-lock-introduction.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><p>很多小伙伴在学习Java的时候，总是感觉Java多线程在实际的业务中很少使用，以至于不会花太多的时间去学习，技术债不断累积！等到了一定程度的时候对于与Java多线程相关的东西就很难理解，今天需要探讨的东西也是一样的和Java多线程相关的！做好准备，马上开车！</p><p>学过Java多线程的应该都知道什么是锁，没学过的也不用担心，Java中的锁可以简单的理解为多线程情况下访问临界资源的一种线程同步机制。</p><p>在学习或者使用Java的过程中进程会遇到各种各样的锁的概念：公平锁、非公平锁、自旋锁、可重入锁、偏向锁、轻量级锁、重量级锁、读写锁、互斥锁等。</p><p>蒙了吗？不要紧！即使你这些都不会也不要紧，因为这个和今天要探讨的关系不大，不过如果你作为一个爱学习的小伙伴，这里也给你准备了一份秘籍：《Java多线程核心技术》，一共19篇祝你一臂之力！免费版的不过瘾，当然也有收费版的！</p><h2 id="一、为什么要使用分布式锁"><a href="#一、为什么要使用分布式锁" class="headerlink" title="一、为什么要使用分布式锁"></a>一、为什么要使用分布式锁</h2><p>我们在开发应用的时候，如果需要对某一个共享变量进行多线程同步访问的时候，可以使用我们学到的Java多线程的18般武艺进行处理，并且可以完美的运行，毫无Bug！</p><p>注意这是单机应用，也就是所有的请求都会分配到当前服务器的JVM内部，然后映射为操作系统的线程进行处理！而这个共享变量只是在这个JVM内部的一块内存空间！</p><p>后来业务发展，需要做集群，一个应用需要部署到几台机器上然后做负载均衡，大致如下图：</p><p><img src="http://img.blog.csdn.net/20180111171903380?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>上图可以看到，变量A存在JVM1、JVM2、JVM3三个JVM内存中（这个变量A主要体现是在一个类中的一个成员变量，是一个有状态的对象，例如：UserController控制器中的一个整形类型的成员变量），如果不加任何控制的话，变量A同时都会在JVM分配一块内存，三个请求发过来同时对这个变量操作，显然结果是不对的！即使不是同时发过来，三个请求分别操作三个不同JVM内存区域的数据，变量A之间不存在共享，也不具有可见性，处理的结果也是不对的！</p><p>如果我们业务中确实存在这个场景的话，我们就需要一种方法解决这个问题！</p><p>为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><h2 id="二、分布式锁应该具备哪些条件"><a href="#二、分布式锁应该具备哪些条件" class="headerlink" title="二、分布式锁应该具备哪些条件"></a>二、分布式锁应该具备哪些条件</h2><p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：</p><blockquote><p>1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；<br>2、高可用的获取锁与释放锁；<br>3、高性能的获取锁与释放锁；<br>4、具备可重入特性；<br>5、具备锁失效机制，防止死锁；<br>6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</p></blockquote><h2 id="三、分布式锁的三种实现方式"><a href="#三、分布式锁的三种实现方式" class="headerlink" title="三、分布式锁的三种实现方式"></a>三、分布式锁的三种实现方式</h2><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足<strong>一致性</strong>（Consistency）、<strong>可用性</strong>（Availability）和<strong>分区容错性</strong>（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。</p><blockquote><p>基于数据库实现分布式锁；<br>基于缓存（Redis等）实现分布式锁；<br>基于Zookeeper实现分布式锁；</p></blockquote><p>尽管有这三种方案，但是不同的业务也要根据自己的情况进行选型，他们之间没有最好只有更适合！</p><h2 id="四、基于数据库的实现方式"><a href="#四、基于数据库的实现方式" class="headerlink" title="四、基于数据库的实现方式"></a>四、基于数据库的实现方式</h2><p>基于数据库的实现方式的核心思想是：在数据库中创建一个表，表中包含<strong>方法名</strong>等字段，并在<strong>方法名字段上创建唯一索引</strong>，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><p>（1）创建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`method_lock`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`method_lock`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`method_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'锁定的方法名'</span>,</span><br><span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注信息'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20180111195240399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>（2）想要执行某个方法，就使用这个方法名向表中插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> method_lock (method_name, <span class="keyword">desc</span>) <span class="keyword">VALUES</span> (<span class="string">'methodName'</span>, <span class="string">'测试的methodName'</span>);</span><br></pre></td></tr></table></figure><p>因为我们对<code>method_name</code>做了<strong>唯一性约束</strong>，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>（3）成功插入则获取锁，执行完成后删除对应的行数据释放锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> method_lock <span class="keyword">where</span> method_name =<span class="string">'methodName'</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：这只是使用基于数据库的一种方法，使用数据库实现分布式锁还有很多其他的玩法！</strong></p><p>使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化：</p><p>1、因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换；</p><p>2、不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程相同，若相同则直接获取锁；</p><p>3、没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在表中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；</p><p>4、不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。</p><p>5、在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。</p><h2 id="五、基于Redis的实现方式"><a href="#五、基于Redis的实现方式" class="headerlink" title="五、基于Redis的实现方式"></a>五、基于Redis的实现方式</h2><p><strong>1、选用Redis实现分布式锁原因：</strong></p><p>（1）Redis有很高的性能；<br>（2）Redis命令对此支持较好，实现起来比较方便</p><p><strong>2、使用命令介绍：</strong></p><p>（1）SETNX</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。</span><br></pre></td></tr></table></figure><p>（2）expire</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key timeout：为key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。</span><br></pre></td></tr></table></figure><p>（3）delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete key：删除key</span><br></pre></td></tr></table></figure><p>在使用Redis实现分布式锁的时候，主要就会使用到这三个命令。</p><p><strong>3、实现思想：</strong></p><p>（1）获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</p><p>（2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p><p>（3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p><p><strong>4、 分布式锁的简单实现代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式锁的简单实现代码</span></span><br><span class="line"><span class="comment"> * Created by liuyang on 2017/4/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedLock</span><span class="params">(JedisPool jedisPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedisPool = jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName       锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquireTimeout 获取超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout        锁的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 锁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">lockWithTimeout</span><span class="params">(String lockName, <span class="keyword">long</span> acquireTimeout, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        Jedis conn = <span class="keyword">null</span>;</span><br><span class="line">        String retIdentifier = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取连接</span></span><br><span class="line">            conn = jedisPool.getResource();</span><br><span class="line">            <span class="comment">// 随机生成一个value</span></span><br><span class="line">            String identifier = UUID.randomUUID().toString();</span><br><span class="line">            <span class="comment">// 锁名，即key值</span></span><br><span class="line">            String lockKey = <span class="string">"lock:"</span> + lockName;</span><br><span class="line">            <span class="comment">// 超时时间，上锁后超过此时间则自动释放锁</span></span><br><span class="line">            <span class="keyword">int</span> lockExpire = (<span class="keyword">int</span>) (timeout / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取锁的超时时间，超过这个时间则放弃获取锁</span></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis() + acquireTimeout;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn.setnx(lockKey, identifier) == <span class="number">1</span>) &#123;</span><br><span class="line">                    conn.expire(lockKey, lockExpire);</span><br><span class="line">                    <span class="comment">// 返回value值，用于释放锁时间确认</span></span><br><span class="line">                    retIdentifier = identifier;</span><br><span class="line">                    <span class="keyword">return</span> retIdentifier;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回-1代表key没有设置超时时间，为key设置一个超时时间</span></span><br><span class="line">                <span class="keyword">if</span> (conn.ttl(lockKey) == -<span class="number">1</span>) &#123;</span><br><span class="line">                    conn.expire(lockKey, lockExpire);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retIdentifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockName   锁的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identifier 释放锁的标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String lockName, String identifier)</span> </span>&#123;</span><br><span class="line">        Jedis conn = <span class="keyword">null</span>;</span><br><span class="line">        String lockKey = <span class="string">"lock:"</span> + lockName;</span><br><span class="line">        <span class="keyword">boolean</span> retFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 监视lock，准备开始事务</span></span><br><span class="line">                conn.watch(lockKey);</span><br><span class="line">                <span class="comment">// 通过前面返回的value值判断是不是该锁，若是该锁，则删除，释放锁</span></span><br><span class="line">                <span class="keyword">if</span> (identifier.equals(conn.get(lockKey))) &#123;</span><br><span class="line">                    Transaction transaction = conn.multi();</span><br><span class="line">                    transaction.del(lockKey);</span><br><span class="line">                    List&lt;Object&gt; results = transaction.exec();</span><br><span class="line">                    <span class="keyword">if</span> (results == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    retFlag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                conn.unwatch();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、测试刚才实现的分布式锁</strong></p><p>例子中使用50个线程模拟秒杀一个商品，使用–运算符来实现商品减少，从结果有序性就可以看出是否为加锁状态。</p><p>模拟秒杀服务，在其中配置了jedis线程池，在初始化的时候传给分布式锁，供其使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by liuyang on 2017/4/20.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool pool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DistributedLock lock = <span class="keyword">new</span> DistributedLock(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        <span class="comment">// 设置最大连接数</span></span><br><span class="line">        config.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 设置最大空闲数</span></span><br><span class="line">        config.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 设置最大等待时间</span></span><br><span class="line">        config.setMaxWaitMillis(<span class="number">1000</span> * <span class="number">100</span>);</span><br><span class="line">        <span class="comment">// 在borrow一个jedis实例时，是否需要验证，若为true，则所有jedis实例均是可用的</span></span><br><span class="line">        config.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">        pool = <span class="keyword">new</span> JedisPool(config, <span class="string">"127.0.0.1"</span>, <span class="number">6379</span>, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seckill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回锁的value值，供释放锁时候进行判断</span></span><br><span class="line">        String identifier = lock.lockWithTimeout(<span class="string">"resource"</span>, <span class="number">5000</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"获得了锁"</span>);</span><br><span class="line">        System.out.println(--n);</span><br><span class="line">        lock.releaseLock(<span class="string">"resource"</span>, identifier);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟线程进行秒杀服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.seckill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service service = <span class="keyword">new</span> Service();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            ThreadA threadA = <span class="keyword">new</span> ThreadA(service);</span><br><span class="line">            threadA.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，结果为有序的：</p><p><img src="http://img.blog.csdn.net/20180115095230690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>若注释掉使用锁的部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seckill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回锁的value值，供释放锁时候进行判断</span></span><br><span class="line">    <span class="comment">//String indentifier = lock.lockWithTimeout("resource", 5000, 1000);</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"获得了锁"</span>);</span><br><span class="line">    System.out.println(--n);</span><br><span class="line">    <span class="comment">//lock.releaseLock("resource", indentifier);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，有一些是异步进行的：</p><p><img src="http://img.blog.csdn.net/20180112111428330?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="5、基于ZooKeeper的实现方式"><a href="#5、基于ZooKeeper的实现方式" class="headerlink" title="5、基于ZooKeeper的实现方式"></a>5、基于ZooKeeper的实现方式</h2><p>ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。基于ZooKeeper实现分布式锁的步骤如下：</p><p>（1）创建一个目录mylock；<br>（2）线程A想获取锁就在mylock目录下创建临时顺序节点；<br>（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；<br>（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；<br>（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。</p><p>这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release方法用于释放锁。</p><p>优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。</p><p>缺点：因为需要频繁的创建和删除节点，性能上不如Redis方式。</p><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>上面的三种实现方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。</p><p>在分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好地控制资源。<br>当然，在具体使用中，还需要考虑很多因素，比如超时时间的选取，获取锁时间的选取对并发量都有很大的影响，上述实现的分布式锁也只是一种简单的实现，主要是一种思想，以上包括文中的代码可能并不适用于正式的生产环境，只做入门参考！</p><hr><p>参考文章：</p><p>1、<a href="https://yq.aliyun.com/articles/60663" target="_blank" rel="noopener">https://yq.aliyun.com/articles/60663</a></p><p>2、<a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1716</a></p><p>3、<a href="https://www.cnblogs.com/liuyang0/p/6744076.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuyang0/p/6744076.html</a></p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> 分布式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Jenkins配置SpringBoot的自动化构建]]></title>
      <url>/article/Jenkins/Auto-construction-with-SpringBoot-and-Jenkins.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="http://blog.csdn.net/xlgen157387/article/details/50353317" target="_blank" rel="noopener">1、使用Jenkins配置Git+Maven的自动化构建</a></p><p><a href="http://blog.csdn.net/xlgen157387/article/details/68961371" target="_blank" rel="noopener">2、Jenkins部署Maven多环境项目（dev、beta、prod）的参数设置</a></p><p><a href="http://blog.csdn.net/xlgen157387/article/details/72852428" target="_blank" rel="noopener">3、使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成</a></p><p><a href="http://blog.csdn.net/xlgen157387/article/details/76216351" target="_blank" rel="noopener">4、使用Generic Webhook Trigger插件实现Jenkins+WebHooks（码云）持续集成–指定具体分支集成</a></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="http://img.blog.csdn.net/20171206182752806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这是一个SpringBoot项目，码云地址为：<a href="https://gitee.com/xuliugen/ufind-server（私有的，不用试啦！）" target="_blank" rel="noopener">https://gitee.com/xuliugen/ufind-server（私有的，不用试啦！）</a></p><p>这里假设你已经配置好了Jenkins的环境，如果还没有配置的话可以参考上文中的相关阅读进行配置。</p><h2 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h2><p><strong>1、新建Job</strong></p><p><img src="http://img.blog.csdn.net/20171206183117420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这里是因为我已经新建了一个相同名字的所以会报已经存在，忽略即可！</p><p><strong>2、设置具体内容</strong></p><p><img src="http://img.blog.csdn.net/20171206183306294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这里指定项目名称和描述，以及源码管理中的Git地址和用户名密码。</p><p><img src="http://img.blog.csdn.net/20171206183400322?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Build指定源代码拉下来之后需要做的事情，Post Steps指定编译好之后需要做的事情。</p><p>其他没有截图的默认即可！</p><p><strong>3、具体分析：</strong></p><p>（1）Build是当把代码拉下来之后需要做的操作，由于是一个maven项目，因此我们需要指定编译打包的命令，这里是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>注意这里没有mvn，因为他是默认使用maven编译的！完整的命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>其中：<code>-Dmaven.test.skip=true</code> 是跳过测试。</p><p>（2）关键是Post Steps的脚本，这里详细的解释：</p><p>首先，我们应该要明白Jenkins的原理，他是这样的，如果我们在新建的时候指定了Maven项目和代码的Git地址，Jenkins首先会通过Git将代码clone到本地，然后执行在<strong>Build</strong>中指定的<strong>pom.xml文件</strong>和<strong>指定的命令</strong>。</p><p>下边是Jenkins的工作区间详细信息（默认位置是：~/.jenkins）：</p><p><img src="http://img.blog.csdn.net/20171206184145223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这里的workspace就是我们创建的任务的工作区间：</p><p><img src="http://img.blog.csdn.net/20171206184307626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以看到就有我们上述创建的<code>ufind-server</code>，如下：</p><p><img src="http://img.blog.csdn.net/20171206185036938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>最后的编译好的jar的位置就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/xuliugen/.jenkins/workspace/ufind-server/ufind-web/target</span><br></pre></td></tr></table></figure><p>然后，我们可以根据需要将编译好的jar移到另外一个位置，然后启动即可，在启动的时候是后台启动，不然的话他的日志会一直显示在Jenkins的任务界面（有兴趣的可以试一下效果！），后台启动的时候需要把进程ID记录到一个文件中，这里是：<code>ufind-web.pid</code></p><p>因此，上图中的脚本的完整解释如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#export BUILD_ID=dontKillMe这一句很重要，这样指定了，项目启动之后才不会被Jenkins杀掉。</span></span><br><span class="line"><span class="built_in">export</span> BUILD_ID=dontKillMe</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定最后编译好的jar存放的位置</span></span><br><span class="line">www_path=/home/xuliugen/www</span><br><span class="line"></span><br><span class="line"><span class="comment">#Jenkins中编译好的jar位置</span></span><br><span class="line">jar_path=/home/xuliugen/.jenkins/workspace/ufind-server/ufind-web/target/</span><br><span class="line"></span><br><span class="line"><span class="comment">#Jenkins中编译好的jar名称</span></span><br><span class="line">jar_name=ufind-web-3.0.0-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取运行编译好的进程ID，便于我们在重新部署项目的时候先杀掉以前的进程</span></span><br><span class="line">pid=$(cat /home/xuliugen/www/ufind-web.pid)</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入指定的编译好的jar的位置</span></span><br><span class="line"><span class="built_in">cd</span>  <span class="variable">$&#123;jar_path&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将编译好的jar复制到最后指定的位置</span></span><br><span class="line">cp  <span class="variable">$&#123;jar_path&#125;</span>/<span class="variable">$&#123;jar_name&#125;</span> <span class="variable">$&#123;www_path&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入最后指定存放jar的位置</span></span><br><span class="line"><span class="built_in">cd</span>  <span class="variable">$&#123;www_path&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#杀掉以前可能启动的项目进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 <span class="variable">$&#123;pid&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动jar，指定SpringBoot的profiles为beta,后台启动</span></span><br><span class="line">java -jar -Dspring.profiles.active=beta <span class="variable">$&#123;jar_name&#125;</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将进程ID存入到ufind-web.pid文件中</span></span><br><span class="line"><span class="built_in">echo</span> $! &gt; /home/xuliugen/www/ufind-web.pid</span><br></pre></td></tr></table></figure><p>这里需要注意的是设置export BUILD_ID=dontKillMe，另一个是每次启动的时候先要杀掉以前的进程，不然的话不会启动还会报错！</p><p>可以看出，只要明白了Jenkins的工作机制，尽管目前Jenkins上SpringBoot相关的插件还没有，但是我们可以一步步的通过脚本的方式进行运行！</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="http://img.blog.csdn.net/20171206190426830?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171206190458445?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>通过游览器访问服务是否可以正确的运行！</p><h2 id="将编译好的jar文件传到另一个服务器"><a href="#将编译好的jar文件传到另一个服务器" class="headerlink" title="将编译好的jar文件传到另一个服务器"></a>将编译好的jar文件传到另一个服务器</h2><p>上述中我们只是通过cp命令将编译好的jar移动到同一个服务器中的另外一个位置，正常情况肯定不会是这样的，他应该是其他服务器上指定的位置，并且服务器的数量可能还不止一个。因此，我们下边研究一下！</p><p>将一个文件从一个服务器移动到另一个服务器使用的是scp命令，例如：</p><p><img src="http://img.blog.csdn.net/20171206191740596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>scp是一个基于ssh的Linux环境下传输文件的好工具，但是使用shell脚本调用scp时会面临一个问题，即scp强制要求通过交互方式输入密码，而不像<code>mysql</code>等拥有<code>-u -p</code>选项。</p><p>下面有两种方法帮助shell脚本跨过输入密码这个障碍！</p><p><strong>1、建立机器间完全信任关系</strong></p><p>假设需要从机器A传输文件至机器B</p><p>（1）在机器A上运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>上述命令会在<code>~/.ssh/</code>目录生成私钥证书<code>id_rsa</code>和公钥证书<code>id_rsa.pub</code>；</p><p>（2）将公钥证书<code>id_rsa.pub</code>复制到机器B的用户根目录的<code>.ssh</code>子目录中，再将文件内容<code>append</code>到文件<code>authorized_keys</code>中。</p><p>其实只要用一条单行命令就可以完成步骤2，它被<strong>commandlinefu.com</strong>的用户投票选为十大最酷的Linux单行命令之一：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id  [-i [identity_file]]  [user@]machine</span><br></pre></td></tr></table></figure><p><code>identity_file</code>是公钥证书的路径，默认情况下是<code>~/.ssh/id_rsa.pub</code>.</p><p>如果要建立双方向的完全信任关系，还要从机器B到机器A再重复一遍上面的操作。</p><p>不过这样的方法并不完美，一是运维成本太高，二是机器间的安全屏障完全消失，安全代价太大，所以本人强烈推荐第二种方法。</p><p><strong>2、expect脚本</strong></p><p>expect脚本是一种建立在tcl基础上的脚本语言，曝光率不高，却堪称shell脚本的好基友。expect脚本为交互而生，被设计为专门针对交互式程序的工具，常与对telnet、ftp、fsck、rlogin、tip、scp等配合使用。使用之前要先安装expect，安装过程（Ubuntu Server）：</p><p><img src="http://img.blog.csdn.net/20171206193940850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Expect中最关键的四个命令是<code>send、expect、spawn、interact</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">send：用于向进程发送字符串</span><br><span class="line">expect：从进程接收字符串</span><br><span class="line">spawn：启动新的进程</span><br><span class="line">interact：允许用户交互</span><br></pre></td></tr></table></figure><p>示例代码例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line">spawn scp -P 22 ufind-web.pid  xuliugen@192.168.1.236:/home/xuliugen/www</span><br><span class="line">expect  <span class="string">"*assword"</span> &#123;<span class="built_in">set</span> timeout 300; send <span class="string">"yourpassword\r"</span>;&#125;</span><br><span class="line">expect <span class="string">"*#"</span></span><br><span class="line">interact</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://img.blog.csdn.net/20171206194102642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以发现文件已经上传成功！</p><p>上面是一个独立的expect脚本文件，如果像把这段脚本嵌入其它shell脚本中就要用到<code>expect -c</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cp ufind-web.pid ufind-web.pid22</span><br><span class="line"></span><br><span class="line">expect -c <span class="string">"</span></span><br><span class="line"><span class="string">spawn scp -P 22 ufind-web.pid  xuliugen@192.168.1.236:/home/xuliugen/www</span></span><br><span class="line"><span class="string">expect  \"*assword\" &#123;set timeout 300; send \"yourpassword\r\";&#125;    </span></span><br><span class="line"><span class="string">expect \"*#\"</span></span><br><span class="line"><span class="string">interact</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20171206201842431?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171206202019273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>简单测试之后，那我们的脚本应该改成如下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> BUILD_ID=dontKillMe</span><br><span class="line"></span><br><span class="line">www_path=/home/xuliugen/www</span><br><span class="line">jar_path=/home/xuliugen/.jenkins/workspace/ufind-server/ufind-web/target</span><br><span class="line">jar_name=ufind-web-3.0.0-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">expect -c <span class="string">"</span></span><br><span class="line"><span class="string">spawn scp -P 22 <span class="variable">$&#123;jar_path&#125;</span>/<span class="variable">$&#123;jar_name&#125;</span>  xuliugen@192.168.1.241:<span class="variable">$&#123;www_path&#125;</span></span></span><br><span class="line"><span class="string">expect  \"*assword\" &#123;set timeout 300; send \"yourpassword\r\";&#125;    </span></span><br><span class="line"><span class="string">expect  \"yes/no\" &#123;send \"yes\r\"; exp_continue;&#125;</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line">expect -c <span class="string">"</span></span><br><span class="line"><span class="string">spawn ssh root@192.168.1.241</span></span><br><span class="line"><span class="string">expect  &#123;</span></span><br><span class="line"><span class="string">        \"*assword\" &#123;set timeout 300; send \"yourpassword\r\";&#125; </span></span><br><span class="line"><span class="string">        \"yes/no\" &#123;send \"yes\r\";exp_continue&#125;</span></span><br><span class="line"><span class="string">&#125;   </span></span><br><span class="line"><span class="string">expect \"*#\" </span></span><br><span class="line"><span class="string">send \"cd /home/xuliugen/www\r\"</span></span><br><span class="line"><span class="string">expect \"*#\"</span></span><br><span class="line"><span class="string">send \"sh startup.sh\r\"</span></span><br><span class="line"><span class="string">expect \"*#\"</span></span><br><span class="line"><span class="string">send \"exit\"</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure><p>这里执行了远程主机192.168.1.241上的一个脚本<code>startup.sh</code>，脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -9 $(cat /home/xuliugen/www/ufind-web.pid)</span><br><span class="line"></span><br><span class="line">java -jar -Dspring.profiles.active=beta ufind-web-3.0.0-SNAPSHOT.jar &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $! &gt; /home/xuliugen/www/ufind-web.pid</span><br></pre></td></tr></table></figure><p>为什么，执行这个远程脚本而不是直接通过expect执行哪？哈哈，你可能没有想到，这是因为本人能力有限，多次尝试使用expect执行都没有成功，所以，不得已才使用这么愚蠢的方式！哈哈，不要打我！</p><p>看执行的结果：</p><p><img src="http://img.blog.csdn.net/20171207124442761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20171207124531195?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>到此，所有配置已经结束！祝大家使用愉快！</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> Jenkins </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Jenkins </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> 自动化集成 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试必备技能：JDK动态代理给Spring事务埋下的坑！]]></title>
      <url>/article/Spring/Spring-transaction-and-dynamic-proxy.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><h2 id="一、场景分析"><a href="#一、场景分析" class="headerlink" title="一、场景分析"></a>一、场景分析</h2><p>最近做项目遇到了一个很奇怪的问题，大致的业务场景是这样的：我们首先设定两个事务，事务parent和事务child，在Controller里边同时调用这两个方法，示例代码如下：</p><p><strong>1、场景A：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//同时调用parent和child</span></span><br><span class="line">        userService.parent();</span><br><span class="line">        userService.child();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User parent = <span class="keyword">new</span> User(<span class="string">"张大壮 Parent"</span>, <span class="string">"123456"</span>, <span class="number">45</span>);</span><br><span class="line">        userMapper.insert(parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User child = <span class="keyword">new</span> User(<span class="string">"张大壮 Child"</span>, <span class="string">"654321"</span>, <span class="number">25</span>);</span><br><span class="line">        userMapper.insert(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实是分别执行了两个事物，执行的结果是两个方法都可以插入数据！如下：</p><p><img src="http://img.blog.csdn.net/20180110203930509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>2、场景B：</strong></p><p>修改上述代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userService.parent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User parent = <span class="keyword">new</span> User(<span class="string">"张大壮 Parent"</span>, <span class="string">"123456"</span>, <span class="number">45</span>);</span><br><span class="line">        userMapper.insert(parent);</span><br><span class="line">        <span class="comment">//在parent里边调用child</span></span><br><span class="line">        child();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User child = <span class="keyword">new</span> User(<span class="string">"张大壮 Child"</span>, <span class="string">"654321"</span>, <span class="number">25</span>);</span><br><span class="line">        userMapper.insert(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Propagation.REQUIRES_NEW的含义表示：如果当前存在事务，则挂起当前事务并且开启一个新事物继续执行，新事物执行完毕之后，然后在缓刑之前挂起的事务，如果当前不存在事务的话，则开启一个新事物。</p></blockquote><p>执行的结果是两个方法都可以插入数据！执行结果如下：</p><p><img src="http://img.blog.csdn.net/20180110204317743?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>场景A和场景B都是正常的执行，期间没有发生任何的回滚，假如child（）方法中出现了异常！</p><p><strong>3、场景C</strong></p><p>修改child（）的代码如下所示，其他代码和场景B一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       User parent = <span class="keyword">new</span> User(<span class="string">"张大壮 Parent"</span>, <span class="string">"123456"</span>, <span class="number">45</span>);</span><br><span class="line">       userMapper.insert(parent);</span><br><span class="line">       child();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       User child= <span class="keyword">new</span> User(<span class="string">"张大壮 Child"</span>, <span class="string">"654321"</span>, <span class="number">25</span>);</span><br><span class="line">       userMapper.insert(child);</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"child Exception...................."</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行结果如下，会出现异常，并且数据都没有插入进去：</p><p><img src="http://img.blog.csdn.net/20180110205742172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20180110205803509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>疑问1：场景C中child（）抛出了异常，但是parent（）没有抛出异常，按道理是不是应该parent（）提交成功而child（）回滚？</strong></p><p>可能有的小伙伴要说了，child（）抛出了异常在parent（）没有进行捕获，造成了parent（）也是抛出了异常了的！所以他们两个都会回滚！</p><p><strong>4、场景D</strong></p><p>按照上述小伙伴的疑问这个时候，如果对parent（）方法修改，捕获child（）中抛出的异常，其他代码和场景C一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       User parent = <span class="keyword">new</span> User(<span class="string">"张大壮 Parent"</span>, <span class="string">"123456"</span>, <span class="number">45</span>);</span><br><span class="line">       userMapper.insert(parent);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           child();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       User child = <span class="keyword">new</span> User(<span class="string">"张大壮 Child"</span>, <span class="string">"654321"</span>, <span class="number">25</span>);</span><br><span class="line">       userMapper.insert(child);</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"child Exception...................."</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后再次执行，结果是两个都插入了数据库：</p><p><img src="http://img.blog.csdn.net/20180110211935338?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20180110211952992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>看到这里很多小伙伴都可能会问，按照我们的逻辑来想的话child（）中抛出了异常，parent（）没有抛出并且捕获了child（）抛出了异常！执行的结果应该是child（）回滚，parent（）提交成功的啊！</p><p><strong>疑问2：场景D为什么不是child（）回滚和parent（）提交成功哪？</strong></p><p>上述的场景C和场景D似乎融为了一题，要么都成功要么都失败！和我们预期的效果一点都不一样！看到这里这就是我们今天要探讨的主题《JDK动态代理给Spring事务埋下的坑！》接下来我们就分析一下Spring事物在该特定场景下不能回滚的深层次原因！</p><h2 id="二、问题本质所在"><a href="#二、问题本质所在" class="headerlink" title="二、问题本质所在"></a>二、问题本质所在</h2><p>我们知道Spring事务管理是通过JDK动态代理的方式进行实现的（另一种是使用CGLib动态代理实现的），也正是因为动态代理的特性造成了上述parent（）方法调用child（）方法的时候造成了child（）方法中的事务失效！简单的来说，在场景D中parent（）方法调用child（）方法的时候，child（）方法的事务是不起作用的，此时的child（）方法像一个没有加事务的普通方法，其本质上就相当于下边的代码：</p><p>场景C本质：</p><p><img src="http://img.blog.csdn.net/20180111104312135?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>场景D本质：</p><p><img src="http://img.blog.csdn.net/20180111103856623?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>正如上述的代码，我们可以很轻松的解释<strong>疑问1和疑问2</strong>，因为动态代理的特性造成了场景C和场景D的本质如上述代码。在场景C中，child（）抛出异常没有捕获，相当于parent事务中抛出了异常，造成parent（）一起回滚，因为他们本质是同一个方法；在场景D中，child（）抛出异常并进行了捕获，parent事务中没有抛出异常，parent（）和child（）同时在一个事务里边，所以他们都成功了；</p><p>看到这里，那么动态代理的这个特性到底是什么才会造成Spring事务失效那？</p><h2 id="三、动态代理的这个特性到底是什么？"><a href="#三、动态代理的这个特性到底是什么？" class="headerlink" title="三、动态代理的这个特性到底是什么？"></a>三、动态代理的这个特性到底是什么？</h2><p>首先我们看一下一个简单的动态代理实现方式：</p><p><img src="http://img.blog.csdn.net/20180111111819312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--执行test1--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--执行test2--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_PREFIX = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//我们使用这个标志来识别是否使用代理还是使用方法本体</span></span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(METHOD_PREFIX)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"========分隔符========"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OrderService orderService = <span class="keyword">new</span> OrderServiceImpl();</span><br><span class="line">        OrderProxy proxy = <span class="keyword">new</span> OrderProxy(orderService);</span><br><span class="line">        orderService = (OrderService) proxy.getProxy();</span><br><span class="line">        orderService.test1();</span><br><span class="line">        orderService.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们执行以下测试方法，注意了此时是同时调用了test1()和test2(）的，执行结果如下：</p><p><img src="http://img.blog.csdn.net/20180111112038067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以看出，在OrderServiceImpl 类中由于test1(）没有调用test2（），他们方法的执行都是使用了代理的，也就是说test1和test2都是通过代理对象调用的invoke（）方法，这和我们场景A和B类似。</p><p>加入我们模拟一下场景C和场景D在test1(）中调用test2（），那么代码修改为如下：</p><p><img src="http://img.blog.csdn.net/20180111112422509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20180111112454278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>执行结果如下：</p><p><img src="http://img.blog.csdn.net/20180111112524205?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>这里可以很清楚的看出来test1(）走的是代理，而test2（）走的是普通的方法，没有经过代理！看到这里你是否已经恍然大明白了呢？</p><p>这个应该可以很好的理解为什么是这样子！这是因为在Java中test1（）中调用test2（）中的方法，本质上就相当于把test2（）的方法体放入到test1（）中，也就是内部方法，同样的不管你嵌套了多少层，只有代理对象<code>proxy</code> 直接调用的那一个方法才是真正的走代理的，如下：</p><p><img src="http://img.blog.csdn.net/20180111113747820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>测试方法和上边的测试方法一样，执行结果如下：</p><p><img src="http://img.blog.csdn.net/20180111113817777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>记住：只有代理对象proxy直接调用的那个方法才是真正的走代理的！</strong></p><h2 id="四、如何解决这个坑？"><a href="#四、如何解决这个坑？" class="headerlink" title="四、如何解决这个坑？"></a>四、如何解决这个坑？</h2><p>上文的分析中我们已经了解了为什么在该特定场景下使用Spring事务的时候造成事务无法回滚的问题，下边我们谈一下几种解决的方法：</p><p>1、我们可以选择逃避这个问题！我们可以不使用以上这种事务嵌套的方式来解决问题，最简单的方法就是把问题提到Service或者是更靠前的逻辑中去解决，使用service.xxxtransaction是不会出现这种问题的。</p><p><strong>2、通过AopProxy上下文获取代理对象：</strong></p><p>（1）SpringBoot配置方式：注解开启 <code>exposeProxy = true</code>，暴露代理对象 (否则AopContext.currentProxy()) 会抛出异常。</p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加注解：</p><p><img src="http://img.blog.csdn.net/20180111130241435?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>修改原有代码的执行方式为：</p><p><img src="http://img.blog.csdn.net/20180112100320796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>此时的执行结果为：</p><p><img src="http://img.blog.csdn.net/20180111130542305?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可见，child方法由于异常已经回滚了，而parent可以正确的提交，这才是我们想要的结果！注意的是在parent调用child的时候是通过try/catch捕获了异常的！</p><p>（2）传统Spring XML配置文件只需要添加依赖个设置如下配置即可，使用方式一样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3、通过ApplicationContext上下文进行解决：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring应用上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestService proxy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从Spring上下文中获取AOP代理对象</span></span><br><span class="line">        proxy = context.getBean(TestService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User parent = <span class="keyword">new</span> User(<span class="string">"张大壮 Parent"</span>, <span class="string">"123456"</span>, <span class="number">45</span>);</span><br><span class="line">        userMapper.insert(parent);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proxy.child();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User child = <span class="keyword">new</span> User(<span class="string">"张大壮 Child"</span>, <span class="string">"654321"</span>, <span class="number">25</span>);</span><br><span class="line">        userMapper.insert(child);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"child Exception...................."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果符合我们的预期：</p><p><img src="http://img.blog.csdn.net/20180111134017781?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>到此为止，我们简单的介绍了一下Spring事务管理中如果业务中有像场景C或者场景D的情况时，如果不清楚JDK动态代理造成Spring事务无法回滚的问题的话就可能是一个开发事故了，说不定是要扣工资的！</p><p>上文中简述了几种场景的事务使用和造成事务无法回滚的根本问题，当然讲述的还是表面的现象，并没有深入原理去分析，尽管如此，如果你在面试的时候能够对这个问题说一下自己的了解，也是一个加分项！</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> SSM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[四张图带你了解Tomcat系统架构--让面试官颤抖的Tomcat回答系列！]]></title>
      <url>/article/Tomcat/Four-pictures-take-you-to-understand-the-tomcat-system-architecture.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat最核心的模块，问题才可以游刃而解，了解了Tomcat的整体架构对以后深入了解Tomcat来说至关重要！</p><h2 id="一、Tomcat顶层架构"><a href="#一、Tomcat顶层架构" class="headerlink" title="一、Tomcat顶层架构"></a>一、Tomcat顶层架构</h2><p>先上一张Tomcat的顶层结构图（图A），如下：</p><p><img src="http://img.blog.csdn.net/20180108192645999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。</p><p>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p><blockquote><p>1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化;<br>2、Container用于封装和管理Servlet，以及具体处理Request请求；</p></blockquote><p>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，也可以提供向相同协议不同端口的连接,示意图如下（Engine、Host、Context下边会说到）：</p><p><img src="http://img.blog.csdn.net/20180108204347710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了！所以整个 Tomcat 的生命周期由 Server 控制。</p><p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的<code>server.xml</code>配置文件中看出，下图是删除了注释内容之后的一个完整的<code>server.xml</code>配置文件（Tomcat版本为8.0）</p><p><img src="http://img.blog.csdn.net/20180108194753633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>详细的配置文件文件内容可以到Tomcat官网查看：<a href="http://tomcat.apache.org/tomcat-8.0-doc/index.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-8.0-doc/index.html</a></p><p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p><p><img src="http://img.blog.csdn.net/20180108194817763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。</p><h2 id="二、Tomcat顶层架构小结："><a href="#二、Tomcat顶层架构小结：" class="headerlink" title="二、Tomcat顶层架构小结："></a>二、Tomcat顶层架构小结：</h2><p>（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；<br>（2） Server掌管着整个Tomcat的生死大权；<br>（4）Service 是对外提供服务的；<br>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；<br>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p><p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p><h2 id="三、Connector和Container的微妙关系"><a href="#三、Connector和Container的微妙关系" class="headerlink" title="三、Connector和Container的微妙关系"></a>三、Connector和Container的微妙关系</h2><p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p><p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p><p>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p><h2 id="四、Connector架构分析"><a href="#四、Connector架构分析" class="headerlink" title="四、Connector架构分析"></a>四、Connector架构分析</h2><p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p><p>因此，我们可以把Connector分为四个方面进行理解：</p><p>（1）Connector如何接受请求的？<br>（2）如何将请求封装成Request和Response的？<br>（3）封装完之后的Request和Response如何交给Container进行处理的？<br>（4）Container处理完之后如何交给Connector并返回给客户端的？</p><p>首先看一下Connector的结构图（图B），如下所示：</p><p><img src="http://img.blog.csdn.net/20180108205854139?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p><p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p><p>（1）Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</p><p>（2）Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</p><p>（3）Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</p><p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p><h2 id="五、Container架构分析"><a href="#五、Container架构分析" class="headerlink" title="五、Container架构分析"></a>五、Container架构分析</h2><p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下（图C）：</p><p><img src="http://img.blog.csdn.net/20180108201104048?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>4个子容器的作用分别是：</p><p>（1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；<br>（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；<br>（3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；<br>（4）Wrapper：每一Wrapper封装着一个Servlet；</p><p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p><p><img src="http://img.blog.csdn.net/20180108201901382?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p><p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</p><p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p><h2 id="六、Container如何处理请求的"><a href="#六、Container如何处理请求的" class="headerlink" title="六、Container如何处理请求的"></a>六、Container如何处理请求的</h2><p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）</p><p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理着继续处理。</p><p><img src="http://img.blog.csdn.net/20180108212100441?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p><p>（1）每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；</p><p>（2）在上层容器的管道的BaseValve中会调用下层容器的管道。</p><p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。</p><p>Pipeline的处理流程图如下（图D）：</p><p><img src="http://img.blog.csdn.net/20180116093931129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>（1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</p><p>（2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</p><p>（3）当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</p><p>（4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，这位面试官一定会对你刮目相看的！</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> Tomcat </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring核心技术原理-（4）-三条路线告诉你如何掌握Spring IoC容器的核心原理]]></title>
      <url>/article/Spring/Three-routes-tell-you-how-to-master-the-core-principles-of-Spring-IoC-container.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><p>本篇文章假设你已经可以熟练的使用Spring了，因此对于某一个细节如何实现的不会在进行详细的阐述！</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>前三篇已经从历史的角度和大家一起探讨了为什么会有Spring，Spring的两个核心概念：IoC和AOP的雏形，Spring的历史变迁和如今的生态帝国。本节的主要目的就是通过一个切入点带大家一起学习一下Spring IoC的核心原理，正如从历史的角度出发讲述为什么会有Spring一样，希望通过这个切入点能让你轻松的掌握住Spring IoC的核心原理。</p><p>本篇文章假设你已经可以熟练的使用Spring了，因此对于某一个细节如何实现的不会在进行详细的阐述！</p><p>前几篇地址：</p><p><a href="http://xuliugen.com/article/Spring/Learn-Spring-through-the-Web-evolution-process.html">Spring核心技术原理-（1）-通过Web开发演进过程了解一下为什么要有Spring?</a></p><p><a href="http://xuliugen.com/article/Spring/Learn-Spring-AOP-through-the-Web-evolution-process.html">Spring核心技术原理-（2）-通过Web开发演进过程了解一下为什么要有Spring AOP?</a></p><p><a href="http://xuliugen.com/article/Spring/The-history-of-Spring-and-today&#39;s-ecological-empire.html">Spring核心技术原理-（3）-Spring历史版本变迁和如今的生态帝国</a></p><h2 id="二、IoC和DI的基本概念"><a href="#二、IoC和DI的基本概念" class="headerlink" title="二、IoC和DI的基本概念"></a>二、IoC和DI的基本概念</h2><p>IoC（控制反转，英文含义：Inverse of Control）是Spring容器的内核，AOP、事务等功能都是建立在此基础上的。从字面意思上可以把IoC拆分为两层含义：<strong>控制和反转</strong>。控制可以理解为是接口实现类的选择权，反转可以理解为这个选择权交给第三方进行管理；总的来说就是某一接口具体实现类的选择控制权从调用类中移除，转交给第三方进行决定，即由Spring容器通过Bean配置来进行控制，这样的话应用程序本身就不用负责依赖对象的创建和维护，而由Spring容器进行管理。</p><p>尽管我们现在对IoC的基本概念都已经熟读与心了，但是在老一辈的时候，IoC的概念还不是很容易被人理解。在那个年代，业界的一位大佬，软件界泰斗级的人物Martin Fowler提出了DI（Dependency Injection，依赖注入）的概念，来代替IoC。</p><p>依赖注入的概念和控制反转的概念从本质上是一样的，只是从不同的侧面描述了这个功能。依赖注入的概念描述的是让调用类对某一接口实现类的依赖关系有第三方容器或其他东西注入，以此来移除对某一接口实现类的依赖。</p><p><img src="http://img.blog.csdn.net/20180104145359933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>时至今日，我们常说的IoC/DI的时候也是把依赖注入和控制反转作为同一个概念来进行阐述的！</p><h2 id="三、从哪里入手IoC容器？"><a href="#三、从哪里入手IoC容器？" class="headerlink" title="三、从哪里入手IoC容器？"></a>三、从哪里入手IoC容器？</h2><p>我曾尝试过很多次，想踏进Spring原理的大门，但是一次次都被毫无头绪的开端而打退！后来逐渐翻阅一些书籍逐渐形成了那么一点点思路，接下来主要按着我的思路探讨一下Ioc容器的基本原理。</p><p>正如我们学习骑自行车一样，开始的时候都是先看别人如何骑的，然后自己才能慢慢的学会（当然发明自行车的人是天才）。学习Spring原理也是一样，只有掌握了基本的Spring的使用，才有可能踏进Spring原理的大门。因此，这里我们从如何使用开始哪？</p><p>1、首先看一下项目结构</p><p><img src="http://img.blog.csdn.net/20180104160938142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>继承关系：</p><p><img src="http://img.blog.csdn.net/20180104160957255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>bean的配置：</p><p><img src="http://img.blog.csdn.net/20180104161043019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Main代码如下：</p><p><img src="http://img.blog.csdn.net/20180104161124631?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>2、相信每一个学习Spring的小伙伴都是从上述的方式学起的，上图中最显眼的两个类就是红色圈圈出的，也设置我们在最开始使用到的，使用UML工具显示最基本的类图关系：</p><p><img src="http://img.blog.csdn.net/20180104161259437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>庞大的一个继承和实现体系！看到这里大致上也就是我要说的<strong>第二条路线</strong>了（下文会详细介绍）！这条路线向我们展示了从Spring最接近用开发人员使用的<code>ClassPathXmlApplicationContext</code>、<code>FileSystemXmlApplicationContext</code>类到Spring的顶层接口之间层层的继承和实现关系。</p><p>看到这里我们似乎还是毫无头绪，这就需要我们借鉴前人的经验了，这个经验就是如何正确的理解<code>BeanFactory</code>和<code>ApplicationContext</code>之间的关系。</p><h2 id="四、BeanFactory和ApplicationContext之间的关系"><a href="#四、BeanFactory和ApplicationContext之间的关系" class="headerlink" title="四、BeanFactory和ApplicationContext之间的关系"></a>四、BeanFactory和ApplicationContext之间的关系</h2><p>我们都知道Spring是通过配置文件、注解、Java类等方式描述Bean与Bean之间的依赖关系，利用Java的反射功能实例化Bean并建立Bean与Bean之间的依赖关系；</p><p>这些底层的工作正是由Spring IoC容器完成的，除此之外Spring IoC容器还提供了Bean实例缓存、生命周期管理、时间发布等高级服务。</p><p>而这里要说的<code>BeanFactory</code>和<code>ApplicationContext</code>都作为Spring IoC容器的形态存在，只不过有些许区别而已，简单的来说：（1）BeanFactory接口的实现类是一个<strong>简单容器</strong>系列，该系列的容器只实现了容器最基本的功能；（2）ApplicationContext接口的实现类是一个<strong>高级容器</strong>系列，该系列的容器在简单容器的基础上增加了很多面向框架的特性，对应用环境做了很多适配，同时添加了很多面向应用的功能，例如：国际化支持和框架事件体系结构等。</p><blockquote><p>通常情况下，我们习惯称BeanFactory为Ioc容器，而称ApplicationContext为应用上下文，有时候我们还直接称ApplicationContext为Spring容器。</p></blockquote><p>至此，我应该可以引出我要说的前两条路线：第一条路线是基于BeanFactory的简单容器系列；第二天路线是基于ApplicationContext的高级容器系列；</p><h2 id="五、第一条路线：基于BeanFactory的简单容器系列"><a href="#五、第一条路线：基于BeanFactory的简单容器系列" class="headerlink" title="五、第一条路线：基于BeanFactory的简单容器系列"></a>五、第一条路线：基于BeanFactory的简单容器系列</h2><p>既然BeanFactory的实现类也是一个容器，那么我们就应该可以使用它来注入我们的Bean和获取我们的Bean，如何使用哪？请看代码：</p><p><img src="http://img.blog.csdn.net/20180104171417349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><blockquote><p>（1）创建IoC配置文件的抽象资源，这个抽象资源包含了BeanDefinition的定义信息（也就是我们在bean.xml文件中配置的一个bean的数据结构）；<br>（2）创建一个BeanFactory，这里使用的是DefaultListableBeanFactory；<br>（3）创建一个载入BeanDefinition的读取器，这里使用的是XmlBeanDefinitionReader来载入XML形式的BeanDefinition，通过一个回调配置给BeanFactory；<br>（4）从定义好的资源位置读入配置信息，具体的解析过程由XmlBeanDefinitionReader来完成。</p></blockquote><p>上述的过程，完成了整个载入和注册Bean的定义之后，我们所需要的IoC容器就建立起来了，这个时候我们就可以直接使用IoC容器了。</p><p>上述代码中使用了<code>DefaultListableBeanFactory</code> 这个BeanFactory默认实现的容器完成了Bean的注入和获取操作，查看其继承和实现关系如下：</p><p><img src="http://img.blog.csdn.net/20180104171713984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><code>BeanFactory</code>位于接口类结构的顶端，它主要定义了IoC容器中应该具有的基本特性，主要接口定义如下，根据名称就可以看出是什么作用，这里不再一一解释：</p><p><img src="http://img.blog.csdn.net/20180104172801609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>面对如此多的接口或类，我们应该如何理解哪？举个栗子，就像一辆汽车一样，BeanFactory中定义了这辆汽车应该具有的基本功能，通过层层的接口继承和实现为这个基本的汽车架构定制了很多特性，比如：可以座几个人，是否可以倒车等，一直到最后才形成了一辆基本可以正常使用的汽车，但到这一步还是一个比较粗糙的产品或者半成品。（可以使用，但对于普通用户不会直接使用）</p><p>而关于这些接口或类的介绍，由于篇幅有限，这里不再一一介绍，主要给大家提供一种思路，如何顺藤摸瓜，掌握第一条理解Spring IoC容器的路线。</p><p>总的来说，BeanFactory是Spring框架的基础设置，面向的是Spring本身，下文中讲述的第二条路线其中也是使用到了上述代码中的过程，我们在实际的开发中很少会直接使用基于BeanFactory的简单容器系列。</p><h2 id="六、第二条路线：基于ApplicationContext的高级容器系列"><a href="#六、第二条路线：基于ApplicationContext的高级容器系列" class="headerlink" title="六、第二条路线：基于ApplicationContext的高级容器系列"></a>六、第二条路线：基于ApplicationContext的高级容器系列</h2><p>相对于第一条路线中的汽车半成品来说，第二个路线下的产品才真正算是一辆可以开的出去的汽车，在基于ApplicationContext的高级容器系列下为汽车新增了很多特性，比如：加了电子档位、加了倒车雷达、全景天窗、全液晶显示器什么的，一直到最后才形成了一辆可以使用的汽车（可以使用，普通用户也可以直接使用）。</p><p><img src="http://img.blog.csdn.net/20180104174322546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>从上图中可以看出来，相对于BeanFactory来说ApplicationContext增加了很多新特性，例如MessageSource接口、ApplicationEventPublisher接口等，所以说ApplicationContext是一个高级形态意义上的IoC容器。</p><p>ApplicationContext的主要实现类是<code>ClassPathXmlApplicationContext</code>、<code>FileSystemXmlApplicationContext</code>，前者是通过从类路径加载配置文件，后者模式从文件系统中装载配置。</p><h2 id="七、第三条路线：基于WebApplicationContext的Web容器系列"><a href="#七、第三条路线：基于WebApplicationContext的Web容器系列" class="headerlink" title="七、第三条路线：基于WebApplicationContext的Web容器系列"></a>七、第三条路线：基于WebApplicationContext的Web容器系列</h2><p>从上边的介绍我们应该已经看出来了，不管是第一条路线还是第二条路线都是基于Java应用的，而我们使用最多的是JavaWeb应用，这也是接下来要说的第三条路线：基于WebApplicationContext的Web容器系列。</p><p><img src="http://img.blog.csdn.net/20180104200201835?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>WebApplicationContext是专门为Web应用准备的，由于Web应用比一般的Java应用拥有更多的特性，因此WebApplicationContext扩展了ApplicationContext。</p><p><img src="http://img.blog.csdn.net/20180104205511762?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>我们在配置Spring集成Spring MVC的时候基本都会使用上述的方式配置Spring容器，ContextLoaderListener通过Web容器上下文参数<code>contextConfigLocation</code>获取Spring配置文件的位置。如果只是使用Xml配置的Bean的话，会使用WebApplicationContext的实现类XmlWebApplicationContext。</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>本文的目的并不是详细的阐述Spring IoC容器的核心原理，这是因为市面上已经有很多书讲述Spring IoC容器的核心原理的，并且简单的一篇文章很难说清楚这么多的内容，这里主要是是希望通过将Spring IoC容器的核心原理内容进行划分，整理为3条基本路线，这样的话逐步击破，才能使自己不会被庞大的代码结构体系所吓到！</p><blockquote><p>纸上得来终觉浅，绝知此事要躬行！</p></blockquote><p>对于Spring IoC容器的核心原理远不止这些，但是基本都是在这三条主线上进行穿插，其他没有提到的如：容器初始化，配置文件解析过程、Bean的解析和注册等，希望大家在在进行学习的时候注意到！</p><p>如果想进一步学习Spring原理的，这里推荐两本书籍《Spring技术内幕-深入解析Spring架构与设计原理》和《精通Spring 4.x 企业应用开发实战》，前者可能有点久，版本不是最新的，但是书中Spring IoC容器和AOP的讲解还是很有参考价值的，后者应该算是市面上一本讲解还算透彻的书籍，值得阅读！</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> SSM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring IoC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[推荐几款非常实用的IDEA插件]]></title>
      <url>/article/Share/Recommended-several-very-useful-IDEA-plugins.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><blockquote><p>推荐几款让你开发效率倍增的IDEA插件，解决你开发中可望而又不好找的插件。</p></blockquote><h2 id="1、Alibaba-Java-Coding-Guidelines"><a href="#1、Alibaba-Java-Coding-Guidelines" class="headerlink" title="1、Alibaba Java Coding Guidelines"></a>1、Alibaba Java Coding Guidelines</h2><p>经过247天的持续研发，阿里巴巴于10月14日在杭州云栖大会上，正式发布众所期待的《阿里巴巴Java开发规约》扫描插件！该插件由阿里巴巴P3C项目组研发。P3C是世界知名的反潜机，专门对付水下潜水艇，寓意是扫描出所有潜在的代码隐患。</p><p>为了让开发者更加方便、快速将规范推动并实行起来，阿里巴巴基于手册内容，研发了一套自动化的IDE检测插件（IDEA、Eclipse）。该插件在扫描代码后，将不符合规约的代码按Blocker/Critical/Major三个等级显示在下方，甚至在IDEA上，我们还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题所在。对于历史代码，部分规则实现了批量一键修复的功能，如此爽心悦目的功能是不是很值得拥有？提升代码质量，提高团队研发效能，插件将会一路同行。<br><img src="http://img.blog.csdn.net/20180104134411717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180104134457115?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="2、iBATIS-MyBatis-plugin"><a href="#2、iBATIS-MyBatis-plugin" class="headerlink" title="2、iBATIS/MyBatis plugin"></a>2、iBATIS/MyBatis plugin</h2><p>轻松通过快捷键找到MyBatis中对应的Mapper和XML，CTRL+ALT+B<br><img src="http://img.blog.csdn.net/20180104134558004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180104134931306?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="3、GsonFormat"><a href="#3、GsonFormat" class="headerlink" title="3、GsonFormat"></a>3、GsonFormat</h2><p>当面对一大堆JSON数据需要生成实体对象的时候，这个时候GsonFormat就派上了用场，一键生成对应实体对象<br><img src="http://img.blog.csdn.net/20180104135030822?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180104135040257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="4、Stack-Overflow"><a href="#4、Stack-Overflow" class="headerlink" title="4、Stack Overflow"></a>4、Stack Overflow</h2><p>编码中几乎所有遇到的错误，都可以在Stack Overflow上找到，因此这个插件可称之为贴心助手，只不过默认使用Google搜索，大家注意。<br><img src="http://img.blog.csdn.net/20180104135139019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180104135157437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="5、Background-Image-Plus"><a href="#5、Background-Image-Plus" class="headerlink" title="5、Background Image Plus"></a>5、Background Image Plus</h2><p>给你一个机会让你面向“对象”编程，设置你喜欢的图片，提升你编码逼格！<br><img src="http://img.blog.csdn.net/20180104135223450?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>安装后，在设置界面设置背景图片文件夹，里边放图片，并且可以设置定时更新：<br><img src="http://img.blog.csdn.net/20180104135248937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>设置完图片之后，重启一下IDEA,然后，你懂的！<br><img src="http://img.blog.csdn.net/20180104135322898?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="6、Lombok"><a href="#6、Lombok" class="headerlink" title="6、Lombok"></a>6、Lombok</h2><p><img src="http://img.blog.csdn.net/20180104135342018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484740&amp;idx=1&amp;sn=151715b1f67f0fc20df1df15c3008f26&amp;chksm=e9c5fcf5deb275e35494f4be71e5f71b742e5b321b2fc50a3bc7b7bfbfbd6dd6df4fd76a5185&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247484740&amp;idx=1&amp;sn=151715b1f67f0fc20df1df15c3008f26&amp;chksm=e9c5fcf5deb275e35494f4be71e5f71b742e5b321b2fc50a3bc7b7bfbfbd6dd6df4fd76a5185&amp;scene=21#wechat_redirect</a><br>从今天起让我们忘记Java中的get/set方法吧！</p><h2 id="7、CodeGlance"><a href="#7、CodeGlance" class="headerlink" title="7、CodeGlance"></a>7、CodeGlance</h2><p>类似SublimeText的Mini Map插件，看下图就知道什么用了：<br><img src="http://img.blog.csdn.net/20180104135422440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="8、其他插件"><a href="#8、其他插件" class="headerlink" title="8、其他插件"></a>8、其他插件</h2><blockquote><p>Markdown support、Maven Helper、JRbel</p></blockquote><hr><p>如果你有好的推荐，欢迎留言评论，让更多的人知道好用的东西！</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> 资源分享 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring核心技术原理-（3）-Spring历史版本变迁和如今的生态帝国]]></title>
      <url>/article/Spring/The-history-of-Spring-and-today's-ecological-empire.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><p>前两篇从Web开发史的角度介绍了我们在开发的时候遇到的一个个坑，然后一步步衍生出Spring Ioc和Spring AOP的概念雏形。Spring从2004年第一个正式版1.0 Final Released发展至今，俨然已经成为了一个生态帝国（开局只有一把枪，装备全靠打！），目前也已经迭代到5.0，拥有诸多的子项目，基本可以解决绝大多数场景的应用！</p><p>而在进一步学习Spring的核心原理之前，有必要和大家一起梳理一下Spring历史版本的变迁，知晓一下每一个版本新增了哪些东西，解决了哪些我们开发中的问题，以便我们更清楚的理解这个生态帝国是如何一步一发展壮大的！</p><p>前几篇地址：</p><p><a href="http://xuliugen.com/article/Spring/Learn-Spring-through-the-Web-evolution-process.html">Spring核心技术原理-（1）-通过Web开发演进过程了解一下为什么要有Spring?</a></p><p><a href="http://xuliugen.com/article/Spring/Learn-Spring-AOP-through-the-Web-evolution-process.html">Spring核心技术原理-（2）-通过Web开发演进过程了解一下为什么要有Spring AOP?</a></p><h2 id="一、Spring历史版本变迁"><a href="#一、Spring历史版本变迁" class="headerlink" title="一、Spring历史版本变迁"></a>一、Spring历史版本变迁</h2><p><strong>1、Spring 1.x</strong></p><p>大概在2004年3月24日这一天，Spring Framework 1.0 final正式出现在我们的视野中，源码项目结构如下：</p><p><img src="http://img.blog.csdn.net/20171227132202302?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>引用依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 1.0当时只包含一个完整的项目，他把所有的功能都集中在一个项目中，其中包含了核心的Ioc、AOP，同时也包含了其他的诸多功能，例如：JDBC、Mail、ORM、事务、定时任务、Spring MVC等。</p><p>由于Spring超前的眼光和博大的精神，在第一个版本的时候已经支持了很多第三方的框架，例如：Hibernate、ibatis、模板引擎等。</p><p>尽管如此，此时的Spring除了最核心的Ioc和AOP之外，其他的模块犹如我们现在众多的开源项目一样，大多是对第三方框架的简单封装！我也相信很多个人或企业也基本都维护了一套类似这种的框架供项目开发使用。</p><p>此时的Spring还很懵懂，只支持基于XML的配置！关于更多关于Spring 1.0 的信息可以参考：</p><p><a href="https://spring.io/blog/2004/03/24/spring-framework-1-0-final-released" target="_blank" rel="noopener">https://spring.io/blog/2004/03/24/spring-framework-1-0-final-released</a></p><p><strong>2、Spring 2.x</strong></p><p>Spring 2.x的源码项目结构如下：</p><p><img src="http://img.blog.csdn.net/20171227134129695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>引用依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过上图中和1.0版本的对比，我们首先可以很直观的感受到Spring做了哪些改变。</p><p>Spring 2.x增加对注解的支持，支持了基于注解的配置。</p><p><strong>3、Spring 3.x</strong></p><p>Spring在GitHub托管的代码，最早的版本只能看到Spring v3.1.0.M2（<a href="https://github.com/spring-projects/spring-framework），源码结构如下：" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework），源码结构如下：</a></p><p><img src="http://img.blog.csdn.net/20171227141143796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Spring 3.x支持了基于Java类的配置。</p><p><strong>4、Spring 4.x</strong></p><p><img src="http://img.blog.csdn.net/20171227141540723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>（1）Spring 4.x新特性：</strong></p><p>Spring 4.x全面支持Java 8.0，支持Lambda表达式的使用，提供了对@Scheduled和@PropertySource重复注解的支持，提供了空指针终结者Optional，对核心容器进行增加：支持泛型的依赖注入、Map的依赖注入、Lazy延迟依赖的注入、List注入、Condition条件注解注入、对CGLib动态代理类进行了增强。</p><p>Spring 4.x还支持了基于Groovy DSL的配置，提高Bean配置的灵活性。</p><p>Spring 4.x开始，Spring MVC基于Servlet 3.0 开发，并且为了方便Restful开发，引入了新的RestController注解器注解，同时还增加了一个AsyncRestTemplate支持Rest客户端的异步无阻塞请求。</p><p><strong>（2）简单的思维导图如下:</strong></p><p><img src="http://img.blog.csdn.net/20171227143911632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>5、Spring 5.x</strong></p><p><img src="http://img.blog.csdn.net/20171227141916907?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Spring 5.x主要新特性：</p><p><img src="http://img.blog.csdn.net/20171227144856974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>6、小结</strong></p><p>Spring 1.x、Spring 2.x、Spring 3.x由于版本比较久，而我从开始就是从Spring 4.0 开始用的，所以更多关于以前版本的信息这里解释的不是很全，上述的源码截图只是作为一种直观地感受，希望能感受到Spring版本的变迁过程。</p><h2 id="二、Spring如今的生态帝国"><a href="#二、Spring如今的生态帝国" class="headerlink" title="二、Spring如今的生态帝国"></a>二、Spring如今的生态帝国</h2><p>Spring从最初的一城一池，发展到如今已经发展为一个生态帝国，旗下拥有诸多的子项目，从最基本的Spring Ioc/AOP使用，到安全管理，再到大数据，Spring已经逐渐的渗入到各个领域，目前，几乎所有JavaWeb相关的开发都可以在Spring中找到合适的方案，为了在开发的时候，防止重造轮子，下边梳理一下Spring的各个子项目，做到心中有数：</p><p><img src="http://img.blog.csdn.net/20171227150059473?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><p>参考文章：</p><p>1、《精通Spring 4.x企业应用开发实战》</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> SSM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring核心技术原理-（2）-通过Web开发演进过程了解一下为什么要有Spring AOP?]]></title>
      <url>/article/Spring/Learn-Spring-AOP-through-the-Web-evolution-process.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><p>上一篇从Web开发演进过程的一个侧面简述了一下为什么会有Spring？事实上只介绍了为什么会有Spring IOC（控制反转/依赖注入）以及Spring IOC的雏形。我们都知道Spring的两个核心知识点是：IOC和AOP。因此，这一篇还是以Web开发演进过程为线索继续探讨一下为什么会有Spring AOP？等介绍完这两个核心的知识点之后，才会进一步展开对Spring核心原理的探讨！</p><p>上一篇地址：</p><p><a href="http://xuliugen.com/article/Spring/Learn-Spring-through-the-Web-evolution-process.html">Spring核心技术原理-（1）-通过Web开发演进过程了解一下为什么要有Spring?</a></p><h2 id="一、Web开发演进到一定阶段的痛点"><a href="#一、Web开发演进到一定阶段的痛点" class="headerlink" title="一、Web开发演进到一定阶段的痛点"></a>一、Web开发演进到一定阶段的痛点</h2><p>我们在初学习Java Web的时候，应该都经历了以下的阶段：</p><p>（1）一个主函数main中包含了所有的方法；<br>（2）将主函数中的方法进行拆分封装，抽取为一个个的方法；<br>（3）按照每一个方法不同的功能分为一个个的类；<br>（4）有了MVC模型之后，我们按照MVC的思想将我们的代码拆分为三层，每层负责不同的功能，进行分门别类的管理；</p><p>很多程序的功能还可以通过继承关系而得到重用，进一步提高了开发效率。再后来，又出现了各种各样的设计模式，使设计程序功能变得得心应手。</p><p>在面向对象的大环境下，我们可以很好地组织代码，通过继承、封装和多态的思想去设计一个个比较让人满意的类，但是我们慢慢的发现，我们的代码中逐渐多了很多重复性的代码，有人可能会想到，把这些重复性的代码抽取出来不就好了吗？是这样的，我们看一下这种思路的一个实例：</p><p><img src="http://img.blog.csdn.net/20171225152705374?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以看到，上述代码功能上确实可以实现，但是我们的业务代码已经被这些非核心的代码所混淆，并且占据了大量的空间！显然这种显示的调用过程成为了我们开发过程中的一个痛点，如何将类似这种的非核心的代码剥离出去成为一个迫切需要解决的问题！</p><p>不仅如此，假设我们要控制每一个方法的访问权限，只允许一部分用户进行访问，在不考虑过滤器的情况下，我们是不是需要在每一个方法开始的时候判断用户是否具有该权限，如果有的话就可以进行访问，如果没有的话，就不允许进行访问！</p><p>诸如此类，还有数据库事务的控制，数据库连接的创建和关闭等等，这些都充斥这大量重复性的模板代码！一个很现实的问题，假如有一天，业务需求不需要进行日志记录了，那岂不是我们需要把以前写的代码，全部删掉！想想都是一件很可怕的事情！</p><h2 id="二、使用设计模式进行一次改进"><a href="#二、使用设计模式进行一次改进" class="headerlink" title="二、使用设计模式进行一次改进"></a>二、使用设计模式进行一次改进</h2><p>如果你对设计模式玩的比较熟的话，这个时候你可能会想到使用<strong>JDK动态代理设计模式</strong>（动态代理设计模式可以在原有的方法前后添加判断、选择或其他逻辑）对上述代码进行改进，（关于什么是JDK动态代理，这里不再详细赘述，有不懂的的可以查阅相关资料具体了解一下！）修改后的代码如下：</p><p><img src="http://img.blog.csdn.net/20171225172716314?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>上述为代理类，红色框中圈出的表示以前业务中的模板代码，这里直接输出表示方法执行的过程，以前的UserServiceImpl修改为如下（直接用输出的方式表示方法执行了）：</p><p><img src="http://img.blog.csdn.net/20171225173044256?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>测试代码如下：</p><p><img src="http://img.blog.csdn.net/20171225173251603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>上述的执行结果可以看出，每次调用一个方法的时候前后都会调用我们期望的代码，实现了我们期望的标准！</p><p>通过JDK动态代理的方式，让我们彻底的解放出来了！</p><h2 id="三、撕开披在AOP身上的一层薄纱"><a href="#三、撕开披在AOP身上的一层薄纱" class="headerlink" title="三、撕开披在AOP身上的一层薄纱"></a>三、撕开披在AOP身上的一层薄纱</h2><p>上述过程中，我们看到在动态代理的<code>invoke</code>方法里边，我们相当于在原有方法的调用前后“植入”了我们的通用日志记录代码，如果你看到这一层的话，那么恭喜你！你已经领悟到了AOP思想最核心的东西了！上述抽取公共代码其实就是AOP中<strong>横切</strong>的过程，代理对象中在方法调用前后“<strong>植入</strong>”自己写的通用日志记录代码其实就是AOP中<strong>织入</strong>的过程！这个织入的代码也就是<strong>横切逻辑</strong>，织入代码的过程其实就是在原有的方法前后<strong>增强</strong> 原方法的过程！总的来说，我们想解决我们开发中的痛点，然后就出现了一种技术，这种技术手段就是AOP。</p><p>AOP书面表述如下：</p><blockquote><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容（Spring核心之一），是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p></blockquote><p><img src="http://img.blog.csdn.net/20171225200459536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="四、AOP与Spring-AOP的关系"><a href="#四、AOP与Spring-AOP的关系" class="headerlink" title="四、AOP与Spring AOP的关系"></a>四、AOP与Spring AOP的关系</h2><p>AOP是一种思想，不同的厂商或企业可能有不同的实现方式，为了更好的应用AOP技术，技术专家们成立了AOP联盟来探讨AOP的标准化，AOP联盟定义的AOP体系结构把与AOP相关的概念大致分为由高到低、从使用到实现的三层关系，AOP联盟定义的AOP体系结构如下图：</p><p><img src="http://img.blog.csdn.net/20171225202005430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>在AOP联盟定义的AOP体系结构下有很多的实现者，例如：AspectJ、AspectWerkz、JBoss AOP、Spring AOP等。Spring AOP就是在此标准下产生的，这里不再深入Spring AOP的其他概念，这些概念会在后期探讨。</p><h2 id="五、其他问题"><a href="#五、其他问题" class="headerlink" title="五、其他问题"></a>五、其他问题</h2><p>上述通过动态代理的方式实现了简单的AOP，但是值得注意的是，我们的代理目标对象必须实现一个接口，要是一个接口的实现类，这是因为再生成Proxy对象的时候这个方法需要一个目标对象的接口：</p><p><img src="http://img.blog.csdn.net/20171225202559491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>显然，这种特殊的场景使用JDK动态代理的技术已经不能够满足我们的使用场景了，又遇到痛点了！凡事不劳我们操心的Spring框架已经替我们想到了，既然你有这种需求，我就使用一种技术帮你实现就行了，Spring在这里使用CGLib的代理方式实现了我们的这种诉求。</p><p>CGLib采用底层的字节码技术，可以为一个类创建子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势的织入横切逻辑。</p><p>看到这里，我们会想以后会不会还有CGLib解决不了得问题啊？我们已经很清楚的知道了对于Spring AOP来说，使用到了JDK动态代理技术和CGLib动态代理技术，这两种方式已经实现了我们绝大多数的场景，如果还有不能满足的需求，迫切需要解决的痛点，我相信可能还会有相应的技术实现AOP。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>上述的过程，大致从一个侧面探讨了一下我们为什么需要AOP，AOP与Spring AOP的关系以及Spring AOP两种实现的方式（JDK动态代理和CGLib动态代理）。</p><p>Spring不尝试提供最为完善的AOP实现，它更侧重于提供一种和Spring IOC容器整个的AOP实现，用于解决实际的问题，在Spring中无缝的整合了Spring AOP、Spring IOC和AspectJ。</p><p>当然，Spring AOP的内容不仅仅有这些！例如：我们在使用Spring AOP的时候只是简单的配置了一下（通过XML或注解进行配置），没有像<code>ProxyDemo</code>测试类中的那样，还需要我们手动的调用<code>ProxyFactory</code> 来创建代理对象，然后调用我们的目标方法，其实Spring AOP在内部已经帮我们把这些事情做好了，具体的原理后期会继续探讨。另外，Spring如何整合Spring IOC和AOP的，这一点也会在后期探讨。</p><p>最后补充一下！动态代理或者设计模式重要吗？很重要！Spring AOP用到了动态代理，Spring事务管理用到了动态代理，MyBatis数据库连接池用到了动态代理，MyBatis创建Mapper用到了动态代理等等，你说重要不！要想踏进这些高层框架原理的大门，设计模式首先是我们的第一段台阶！</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> SSM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring AOP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring核心技术原理-（1）-通过Web开发演进过程了解一下为什么要有Spring?]]></title>
      <url>/article/Spring/Learn-Spring-through-the-Web-evolution-process.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><h2 id="一、知史可以明鉴"><a href="#一、知史可以明鉴" class="headerlink" title="一、知史可以明鉴"></a>一、知史可以明鉴</h2><p>我们学习技术的时代赶上了最好的时代，跳过了很多前人经常踩的坑，前人在踩坑的过程中总结了很多经验和教训，而新时代的我们只是继承了前人的经验和教训，而忽略了这些采坑的过程，以至于我们面对很多新技术都不知道他是什么？他为什么存在？他为什么可以解决这个问题？更不知道如何掌握其原理！云里雾里一头雾水！</p><p>交流群的很多小伙伴，常常私聊我让我推荐一下学习SSM框架的视频和资料，我首先会打开他的资料卡看一下他的年龄，如果超过了他这个年龄应有的水平，我就会问他JSP+Servlet学了吗？很多小伙伴的回答是简单的学了一下，然后，我会给他一个关于JSP+Servlet的实战项目，顺便给他们找一些SSM的项目，并且建议他们首先看这个JSP+Servlet的实战项目。</p><p>更有甚者，学了基础之后就开始学习Spring Boot的，当问他们Spring Boot是什么的时候，大致也可以回答出来“约定大于配置”，“用起来很简单”，但是在细究其原理，也是吱吱呜呜，一知半解！如果我们没有经历过Spring最开始繁琐的配置、然后一步步精简，根本体会不到为什么会有Spring Boot这个东西！</p><blockquote><p>不先学习常见的设计模式直接看Spring、MyBatis等源码，简直就是一个找虐的过程！不掌握Servlet原理、基本的Tomcat容器技术上来就看Spring MVC源码同样也是一个打击自信心的好地方！</p></blockquote><p>学习是一个循序渐进的过程，不能急于求成，但也不能过分钻牛角尖！不能再一个技术上停滞不前，也不能如”蜻蜓点水”一般寥寥掠过！同样，如果你还没有掌握好Servlet和简单的设计模式我建议你先去查阅相关的资料进行系统的学习。</p><p>我也相信很多图书或视频等资料都忽略了讲述为什么会有Spring的过程，要么是简单概括并且痛斥EJB的各种弊端，要么就是只字不提，这是一种对读者很不负责任的表现，知史可以明鉴！因此，在进一步学习Spring核心原理之前，我们有必要介绍一下整个Web发展的简单历史，一步步引出为什么会有Spring！</p><h2 id="二、Web发展简史"><a href="#二、Web发展简史" class="headerlink" title="二、Web发展简史"></a>二、Web发展简史</h2><p>老一辈的软件开发人员一般经历了从Model1到Model2，然后到后来的三层模型，最后到现在的Spring Boot。如果从Model1到Model2说起到我们现在使用的Spring Boot为整个时间轴的话，大致可以分为4个阶段：</p><p>（1）初级阶段：使用Model1/Model2/三层模模型进行开发；</p><p>（2）中级阶段：使用EJB进行分布式应用开发，忍受重量级框架带来的种种麻烦；</p><p>（3）高级阶段：使用Spring春天带给我们的美好，但是还要忍受很多繁琐的配置；</p><p>（4）骨灰级阶段：使用Spring Boot，畅享“预定大于配置”带给我们的种种乐趣！</p><h2 id="三、Web发展初级阶段"><a href="#三、Web发展初级阶段" class="headerlink" title="三、Web发展初级阶段"></a>三、Web发展初级阶段</h2><p><strong>1、Model1开发模式：</strong></p><p>Model1的开发模式是：JSP+JavaBean的模式，它的核心是Jsp页面，在这个页面中，Jsp页面负责整合页面和JavaBean（业务逻辑），而且渲染页面，它的基本流程如下：</p><p><img src="http://img.blog.csdn.net/20171224141251776?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>相信很多小伙伴在刚学习Web的时候，肯定使用到了Model1开发模式，也就是我们的业务代码、持久化代码直接写在Jsp页面里边，使用Jsp直接处理Web浏览器的请求，并使用JavaBean处理业务逻辑。</p><p>利用我们现在熟悉的MVC模型的思想去看，虽然编写代码十分容易，但Jsp混淆了MVC模型中的视图层和控制层，高度耦合的结果是Jsp代码十分复杂，后期维护困难！</p><p><strong>2、Model2开发模式：</strong></p><p>Model1虽然在一定程度上解耦了，但JSP依旧即要负责页面控制，又要负责逻辑处理，职责不单一！此时Model2应运而生，使得各个部分各司其职，Model2是基于MVC模式的。</p><p>Model2的开发模式是：Jsp+Servlet+JavaBean的模式，它和Model1不同的是，增加了Servlet，将调用页面数据，调用业务逻辑等工作放到了Servlet中处理，从而减轻了Jsp的工作负担！它的基本流程如下：</p><p><img src="http://img.blog.csdn.net/20171224142257644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Model2开发模式将Servlet的概念引入架构体系中，使用它来分配视图层Jsp的显示页面，同时调用模型层的JavaBean来控制业务逻辑。</p><p><strong>3、Model1和Model2的区别：</strong></p><p>Model1：简单，适合小型项目的开发，但是Jsp的职责过于繁重，职责分工不明确。在后期的维护工作中，必将为此付出代价！</p><p>Model2：相对于Model1来说，职责分工更为明确，在Model1的基础上，抽取了Servlet层，体现了一个分层的思想，适合大型的项目开发！（当时的评判标准是适合大型项目开发的，现在看起来已经过时了！）</p><p>Model2看起来已经尽善尽美了，尽管如此，他还不能称之为一个比较完善的MVC设计模式！</p><p><strong>4、Model1和Model2与三层的对比：</strong></p><p>在Model2中，我们将Servlet抽取出单独的一层，和Jsp协作完成用户数据交互的工作，也就是表示层。那么作为三层结构来说，又做了什么样的改进呢？三层则是在此基础上，将JavaBean再一次进行分割：<strong>业务逻辑、数据持久化</strong>，三层如下：</p><p>（1）表示层，JSP/Servlet；<br>（2）业务逻辑层：业务规则；<br>（3）持久化层：主要包装持久化的逻辑 ；</p><p><img src="http://img.blog.csdn.net/20171224145135671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>各个的耦合性如下图：</p><p><img src="http://img.blog.csdn.net/20171224145428221?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>Model1、Model2、三层是在解耦的基础上一步步进化而来，通过解耦我们可以进行进一步的抽象，以应对现实需求的变动。</p><h2 id="四、Web发展中级阶段、高级阶段和骨灰级阶段"><a href="#四、Web发展中级阶段、高级阶段和骨灰级阶段" class="headerlink" title="四、Web发展中级阶段、高级阶段和骨灰级阶段"></a>四、Web发展中级阶段、高级阶段和骨灰级阶段</h2><p>这一小节似乎有点应付，对于中级阶段，因为我没有用过EJB，在这里不敢妄加评论，以免误导大家。但是相信每一位接触过Spring的小伙伴，都应该知道Rod Johnson在2002年编写的《Expert One-to-One J2EE Design and Development》一书，Rod 在本书中对J2EE正统框架臃肿、低效、脱离现实的种种学院派做法提出了质疑，并以此书为指导思想，编写了interface21框架，也就是后来的Spring。</p><p>对于高级阶段和骨灰级阶段是我们后期一系列文章的重点，本篇只作为一个阶段划分，不做过多的解释，因此让我们重新回到Web发展的初级阶段。</p><p>对EJB有兴趣的可以参考文章：<a href="http://www.uml.org.cn/j2ee/2009112011.asp" target="_blank" rel="noopener">http://www.uml.org.cn/j2ee/2009112011.asp</a></p><h2 id="五、Web发展初级阶段存在的问题"><a href="#五、Web发展初级阶段存在的问题" class="headerlink" title="五、Web发展初级阶段存在的问题"></a>五、Web发展初级阶段存在的问题</h2><p>经历过初级阶段的小伙伴肯定看得懂下边的一个项目结构，一个简单的MVC三层结构，使用JSP+Servlet+MySQL+JDBC技术，面向接口编程：</p><p><img src="http://img.blog.csdn.net/20171224160249930?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>1、面向接口编程的实例化对象</strong></p><p>以用户管理模块为例，有一个UserDao接口，有一个接口的实现类UserDaoImpl，如下：</p><p><img src="http://img.blog.csdn.net/20171224162423726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>由于是面向接口编程，因此我们在每次使用UserDao的时候，都要进行实例化一次，实例化代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br></pre></td></tr></table></figure><p>我们在每次使用UserDao的时候都需要进行实例化，当然不仅仅有UserDao需要进行实例化，还有很多需要进行实例化的，举例如下：</p><p><img src="http://img.blog.csdn.net/20171224162830677?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以看出，每一个方法中都需要进行实例化我们需要用到的接口的实现类，这就会存在大量的实例化对象，并且他们的生命周期可能就是从方法的调用开始到方法的调用结束为止，加大了GC回收的压力！</p><p><strong>2、使用单例模式的一次改进</strong></p><p>了解设计模式的可能会想到使用单例模式的方式来解决这个问题，以此来避免大量重复的创建对象，但是我们还要考虑到众多的这种对象的创建都需要改成单例模式的话，是一个耗时耗力的操作。</p><p>对于这个系统来说，如果都把这种面向接口的对象实现类转换为单例模式的方式的话，大概也要写十几个或者上百个这种单例模式代码，而对于一个单例模式的写法来说，往往是模板式的代码，以静态内部类的方式实现单例模式如下：</p><p><img src="http://img.blog.csdn.net/20171224171710554?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>可以看出，这种方式有两个问题：</p><p>（1）业务代码与单例模式的模板代码放在一个类里，耦合性较高；<br>（2）大量重复的单例模式的模板代码；</p><p>从上述可以看出，使用的单例模式虽然从性能上有所提高，但是却加重了我们的开发成本。因此只会小规模的使用，例如我们操作JDBC的Utils对象等。</p><p><strong>3、我们开发中遇到的痛点</strong></p><p>从上述代码的演进过程我们可以看得出来，我们即需要一个单例的对象来避免系统中大量重复对象的创建和销毁，又不想因为使用单例模式造成大量重复无用的模板代码和代码的耦合！</p><p>（突然想到一个段子，想和大家分享一下：产品经理在给甲方汇报方案的时候说了两种方案：一种是实用的，一种是美观的，问甲方希望选择哪一种？甲方说：有没有即实用又美观的！）</p><p><strong>4、我们还能怎么做</strong></p><p>作为学院派的书生来说，我们可能会联想到“数据库连接池”,我们在获取数据库连接的时候会从这个池子中拿到一个连接的，假设这个数据库连接池很特殊，有且只能有N个数据库连接，并且每一个连接对象都不同（假设），那么这个不就相当于每一个连接都是单例的了吗？既可以避免大量对象的创建，也可以实现不会出现大量重复性的模板代码。</p><p>因此，这里应该有一个大胆的想法，我们是否可以建立一个池子，将我们的接口实现类对象放入到这个池子中，我们在使用的时候直接从这个池子里边取就行了！</p><p><strong>5、这个池子</strong></p><p>如果我们要创建这个池子，首先要确定需要把哪些对象放进这个池子，通过怎样的方式放进去，放进去之后如何进行管理，如何进行获取，池子中的每一个对象的生命周期是怎么样的等等这些东西都是我们需要考虑到的！</p><p><strong>6、恭喜你</strong></p><p>如果你已经了解了上述Web演进的过程，以及我们想要创建的这个池子，那么恭喜你！你已经打开了Spring核心原理的大门了！</p><p>上述我们想要创建的池子其实就是Spring容器的雏形，将接口实现类的对象放进池子进行管理的过程其实也是Spring IOC依赖注入、控制反转的雏形！</p><p>Spring的依赖注入/控制反转就是从我们的配置文件或注解中的得到我们需要进行注入到Spring容器的实现类的信息，Spring IOC通过这些配置信息创建一个个单例的对象并放入Spring容器中，Spring容器可以看做是一个集合保存着我们的这些对象。</p><p><strong>7、小总结</strong></p><p>上文中主要从一个切入点探讨了一下为什么有Spring，以及介绍了一下Spring IOC和Spring容器的基本雏形概念，当然还可以从其他方面进行切入。这里没有进一步探讨AOP的概念，对于新入门的小伙伴来说，这个确实有必要讨论一下，也决定在后续文章中由浅入深的探讨一下，而对于老手来说，其实我上边写的基本上是浪费大家时间的！</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>从历史的角度来说，不同时期的大革命在爆发之前，都会有一个蓄谋已久的“导火线”！Spring的出现，同样顺应了历史发展潮流，正是由于那个时期J2EE开发标准的种种弊端造就了Spring的出现！即使不是Spring，同样也会有其他类似的产品出现，只不过历史选择了Spring，Spring顺应了历史！没有切肤之痛，是不会体会到Spring带给我们的乐趣与快感！</p><p>同样的，每个时代都会有每一个时代的问题，Spring也是！正如十年前我们的计算机可能带不动一款游戏，今天我们的计算机也有可能带不动一款如今的游戏，同样十年后的计算机也会有一款他带不动的游戏出现！以一种发展的眼光去看Spring，就可以很好的理解Spring Boot是以一种什么样的角色出现在我们的面前了！</p><p>时代选择了Spring，同样Spring也被这个时代所选择着！你我只有不停的进步，不停地学习才能跟上这个时代！</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> SSM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大数据时代：我们是一朝天子，还是一世奴隶？]]></title>
      <url>/article/BigData/Big-Data-Age-Are-we-an-emperor-or-a-slave.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><p>很多人还没有搞清楚什么是PC互联网的时候，移动互联网来了；还没有搞清楚移动互联网的时候，大数据时代又来了！</p><p>大数据一词最早出现是在1980年著名未来学家托夫勒在其所著的《第三次浪潮》中，书中提出“如果说IBM的主机拉开了信息化革命的大幕，那么‘大数据’才是第三次浪潮的华彩乐章。” 2008年9月《自然》杂志推出了名为“大数据”的封面专栏，从此大数据开始崭露头角，2009年“大数据”才成为信息技术行业中的热门词汇。马云曾说过：很多人还没有搞清楚什么是PC互联网的时候，移动互联网来了；我们还没有搞清楚移动互联网的时候，大数据时代又来了！</p><p><img src="http://img.blog.csdn.net/20171224101811695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>大数据是指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产[百度百科]。</p><p>我们生活在一个大数据的时代，谁都不曾逃脱！对于我们个人而言，是大数据把我们“照顾”得服服帖帖的，满足我们的需求和好奇心，无须多讲它就能懂我们！甚至比你的男朋友或女朋友更了解你！我们每天产生着各种各样的行为记录，无论巨细，一一被记载再案。很现实的一个问题，我们刚逛完某东搜了某款手机，想了一下钱包没钱，只能暂把他放入购物车，过段时间如果你在游览某条你可能会惊讶的发现，某条的推送广告可能就是你刚才想买而又没有买的东西！！！（不相信的话可以试一下，注意：这不是某条和某东的软文）</p><p><img src="http://img.blog.csdn.net/20171224101900127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>我们每天早上睁眼起来，拿起手机像批阅奏折一样，游览着我们昨天关注的事情，同时留下今后要关注的事情，像个皇帝一样关心着国家大事，样样巨细！面面俱到！你需要做的就是把你需要关心的事情告诉这些大臣：臣子们！我可能需要买个手机啦！你们帮忙瞅瞅！可能就在不一会的功夫你就会收到各个大臣的奏折等你批阅！大数据时代我们貌似仅仅是一只批阅大臣奏折的皇帝！</p><p><img src="http://img.blog.csdn.net/20171224101924137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><blockquote><p>你喜欢看励志的作品，就会给你推很多鸡汤文;<br>你喜欢看娱乐八卦，就会给你推很多娱乐大爆料;<br>你关注家国民生，就会给你推各种国富民强、社会安康的大事l;<br>你喜欢手机数码，就会给你推送很手机电脑产品……</p></blockquote><p>我们生活在大数据时代中，我们被计算过、被定位过、被定向过那一条条定制化过的推送信息，其实就是我们认知世界的一块块碎片，堆砌出的世界实质也成了我们心中世界的映射！所以，你还敢在办公室电脑或实验室电脑买TT或者WW吗？</p><p>每年双十一或双十二，各大电商平台会根据全国各地往年的购买倾向以及存入购物车的商品情况提前向各个库房布置商品！腾讯根据大数据通过一张小时候的照片找到多年被拐卖的儿童；公安部根据人的走路步伐特征抓到罪犯！！！诸如此类枚不胜举！如果你还觉得这些和你无关的话，那请看下边一张图片：</p><p><img src="http://img.blog.csdn.net/20171224102016368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>看到了吗，两张让人细思极恐的图片，（放这两张图多少让人感觉好像要被有关部门请去喝茶的感觉！如果你是一个遵纪守法的人，那很庆幸，这些技术都是为你保驾护航的，是你生活安枕无忧的壁垒！）当你走在马路上正在思考要不要闯红灯的时候，你的个人信息可能已经被交通人员看到了！</p><p>可以说，我们已经被各种各样的大数据包围了！“十面埋伏”！但是，我们不可否定的是大数据时代给我们带来了很多便利和实惠，也给企业带来了很多机遇与挑战！</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>大数据时代，已成不可逆的大潮流！对于企业若仍停滞迟迟未转型去把握甚至是迎合大数据时代，终将被时代淘汰！对于程序员的我们，如果也停滞不前，也终将被一批批新人所取代！作为站在互联网浪尖上的弄潮儿，我们不得不跟紧时代的步伐！我们不想坐在办公室每天都做些增删改查的事情！等我们到了30岁或者40岁，面试的时候面试官问你会什么，你说我只会增删改查！那好，你先回去等消息吧！</p><p>值得庆幸的是我们搭上了Java的顺风车，各种主流的大数据平台都支持Java语言，后期Java开发人员发展的趋势可能也需要我们会大数据了！如果你是新手请不要气馁，踏踏实实、安安心心一步一步走，走到这一步只是时间问题！如果你是老手并且你已经鼓起勇气准备学大数据了！恭喜你！你已经抓住了自己的命运，在自己的职业生涯中努力前行吧！</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小白入门：大型网站技术架构负载均衡技术介绍及学习资源推荐]]></title>
      <url>/article/Distributed/Large-site-technology-architecture-load-balancing-technology-introduction.html</url>
      <content type="html"><![CDATA[<!-- build time:Fri Jan 26 2018 14:16:06 GMT+0800 (中国标准时间) --><p>十年间，负载均衡的前沿技术层出不穷，令用户眼花缭乱。经常在技术网站、文档中出现的“四层负载均衡”、“七层负载均衡”字眼有什么含义?有什么区别?对客户网络有哪些不同的优化?</p><p>在大型的网站服务器集群中，负载均衡技术是必不可少的。使用负载均衡的技术架构，能够有效避免后端服务出现单点故障，提升服务的稳定性。</p><h2 id="一、负载均衡简介"><a href="#一、负载均衡简介" class="headerlink" title="一、负载均衡简介"></a>一、负载均衡简介</h2><p>负载均衡，英文名称为LoadBalance，其意思就是将负载(工作任务)进行平衡，分摊到多个操作单元上进行执行(例如Web服务器、FTP服务器等)，实现多个服务器共同完成工作任务的目标。负载均衡建立在现有网络结构之上，它提升了服务器的性能、提高了带宽利用率，增强了网络的灵活性和可靠性。经过十年的发展，负载均衡已经成为网络应用的重要设备，甚至成为大型网络应用的核心设备，与基础路由、交换设备市场并驾齐驱。</p><p>负载均衡构建在现有网络结构之上，可以方便有效地扩展服务器资源。通常将大量的并发请求分散至多个节点上分别处理，减少客户端的等待时间；也可以将单个重负载的运算分担到多个节点上做并行处理，最后进行汇总。</p><h2 id="二、负载均衡的作用"><a href="#二、负载均衡的作用" class="headerlink" title="二、负载均衡的作用"></a>二、负载均衡的作用</h2><p><img src="http://img.blog.csdn.net/20171130181726163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><strong>2.1、请求分发</strong></p><p>请求分发即按照一定的算法将大量的并发请求分散至多个节点的服务器上处理，减轻单台服务器的压力，减少请求响应时间以及提升系统并发量。</p><p><strong>2.2、故障转移</strong></p><p>通过心跳机制检测判断各个服务器的状态，能够自动剔除不可用的服务器并将请求发送可用服务器，减少服务出现不可用的概率，提高可用性。</p><p><strong>2.3、总的来说</strong></p><p>网络负载均衡允许使用相同的群集 IP 地址集指定群集中所有计算机的地址，并且它还为每个主机保留一组唯一专用的 IP 地址。对于负载平衡的应用程序，当主机出现故障或者脱机时，会自动在仍然运行的计算机之间重新分发负载。当计算机意外出现故障或者脱机时，将断开与出现故障或脱机的服务器之间的活动连接。任何一种情况下，都可以在准备好时将脱机计算机明确地重新加入群集，并重新共享群集负载，以便使群集中的其他计算机处理更少的流量。</p><h2 id="三、负载均衡的分类"><a href="#三、负载均衡的分类" class="headerlink" title="三、负载均衡的分类"></a>三、负载均衡的分类</h2><p><img src="http://img.blog.csdn.net/20171130173331452?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>平时我们常用的有四层负载均衡和七层负载均衡，四层的负载均衡是基于IP和端口实现的，七层的负载均衡是在四层的基础上，基于URL等信息实现。</p><p><strong>3.1、常用于四层负载均衡的软件（还有F5、NetScaler等硬件负载均衡器）有：</strong></p><p><strong>LVS</strong>：重量级软件，本身不支持正则表达式，部署起来比较麻烦，但是性能高，应用范围广，一般的大型互联网公司都有用到。</p><p><strong>HAProxy</strong>：轻量级软件，支持的负载均衡策略非常多，较灵活。</p><p><strong>Nginx</strong>：轻量级软件，支持的协议少（HTTP、HTTPS和Email协议），对于Session支持不友好。</p><p><strong>3.2、常用于七层负载均衡的软件有：</strong></p><p><strong>HAProxy</strong>：全面支持七层代理，灵活性高，支持Session会话保持。</p><p><strong>Nginx</strong>：可以针对HTTP应用进行分流，正则规则灵活，支持高并发，部署简单。</p><p><strong>Apache</strong>：性能较差，一般不考虑。</p><p><strong>MySQL Proxy</strong>：官方的数据库中间件，可以实现读写分离，负载均衡等功能，但是对分表分库支持不完善（可选替代品：Atlas，Cobar，TDDL）。</p><h2 id="四、技术原理"><a href="#四、技术原理" class="headerlink" title="四、技术原理"></a>四、技术原理</h2><p><img src="http://img.blog.csdn.net/20171130173458533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>四层负载均衡类似路由器的转发，通过修改报文中的目标地址和端口，然后直接转发给该服务器，只需要一个TCP连接即可。七层负载均衡通过类似于代理的机制进行转发，负载均衡服务器会分别与客户端和后端的服务器都建立TCP连接。</p><h2 id="五、应用场景"><a href="#五、应用场景" class="headerlink" title="五、应用场景"></a>五、应用场景</h2><p>四层负载均衡一般用于TCP应用中，比如基于C/S架构开发的ERP系统。七层负载均衡大多应用于使用HTTP/HTTPS协议搭建的网站和内部平台系统。</p><p>从市场份额来看，七层负载均衡设备还是以国外厂商占据主导地位，国内能够进行自主研发的只有太一星晨等少数的几家厂商。而且，国内负载均衡厂商应用场景以链路负载为主，难以进入占据负载均衡市场70%份额、主导负载均衡技术发展的服务器负载均衡市场，更缺乏在大型数据中心及大型门户网站使用案例。<br>六、福利时刻之如何学习？<br>对于很多人来说，对于分布式集群这些根本无从学起，如果你已经对基础的Java基础掌握住了，想入门分布式的话，特推荐几本书籍供大家参考，这些书籍比简单的几篇文章或几段视频更能系统的学习理解，总之很不错！</p><p>《大型网站技术架构：核心原理与案例分析 李智慧》</p><p><img src="http://img.blog.csdn.net/20171130173550314?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>《大型分布式网站架构设计与实践 陈康贤》</p><p><img src="http://img.blog.csdn.net/20171130173559467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>《高性能网站构建实战 刘鑫》</p><p><img src="http://img.blog.csdn.net/20171130173607150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>以上三本书籍本人都看过，感觉很不错，特推荐给大家，一键保存请看下边（仅供学习交流，禁止用于商业用途，如需要请购买正版，请务必在24小时之内删除！）：</p><p><img src="http://img.blog.csdn.net/20171130173616800?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGxnZW4xNTczODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>链接地址：<a href="https://pan.baidu.com/s/1mhJiPmS" target="_blank" rel="noopener">https://pan.baidu.com/s/1mhJiPmS</a> 密码：39po，链接失效请在文章底部留言邮箱或私信邮箱地址，会在第一时间回复！</p><!-- rebuild by neat -->]]></content>
      
        <categories>
            
            <category> 分布式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
